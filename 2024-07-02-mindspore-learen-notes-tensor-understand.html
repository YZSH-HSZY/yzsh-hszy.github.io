<!DOCTYPE html>
<html lang="zh-cn">
        <head>
                        <meta charset="utf-8" />
                        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                        <meta name="generator" content="Pelican" />
                        <title>Mindspore Learen Notes -- Tensor Understand.</title>
                        <link rel="stylesheet" href="https://yzsh-hszy.github.io/theme/css/main.css" />
                                <link href="https://yzsh-hszy.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Welcome to YZSH-HSZY blog. Atom Feed" />
    <meta name="description" content="张量介绍 张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例 …" />
        </head>

        <body id="index" class="home">
                <header id="banner" class="body">
                        <h1><a href="https://yzsh-hszy.github.io/">Welcome to YZSH-HSZY blog.</a></h1>
                        <nav><ul>
                                                <li><a href="https://yzsh-hszy.github.io/category/cpython.html">Cpython</a></li>
                                                <li><a href="https://yzsh-hszy.github.io/category/linux.html">Linux</a></li>
                                                <li class="active"><a href="https://yzsh-hszy.github.io/category/mindspore.html">Mindspore</a></li>
                                                <li><a href="https://yzsh-hszy.github.io/category/qemu.html">Qemu</a></li>
                                                <li><a href="https://yzsh-hszy.github.io/category/qt.html">Qt</a></li>
                                                <li><a href="https://yzsh-hszy.github.io/category/test.html">Test</a></li>
                        </ul></nav>
                </header><!-- /#banner -->
  <section id="content" class="body">
    <article>
      <header>
        <h1 class="entry-title">
          <a href="https://yzsh-hszy.github.io/2024-07-02-mindspore-learen-notes-tensor-understand.html" rel="bookmark"
             title="Permalink to Mindspore Learen Notes -- Tensor Understand.">Mindspore Learen Notes -- Tensor Understand.</a></h1>
      </header>

      <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2024-07-02T12:00:00+08:00">
                Published: Tue 02 July 2024
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="https://yzsh-hszy.github.io/author/yzsh-hszy.html">YZSH-HSZY</a>
                </address>
        <p>In <a href="https://yzsh-hszy.github.io/category/mindspore.html">Mindspore</a>.</p>
        
</footer><!-- /.post-info -->        <h2>张量介绍</h2>
<p>张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 𝑛 维空间内，有 $n^r$ 个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。 𝑟 称为该张量的秩或阶（与矩阵的秩和阶均无关系）。</p>
<p><strong>注意</strong> 张量是一种特殊的数据结构，与数组和矩阵非常相似。张量（Tensor）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。</p>
<h2>张量与矩阵与数组与向量的区别</h2>
<p>在numpy中，数据的结构有数组、矩阵、向量这几种描述方式，而在深度学习中通常使用张量来描述所有数据和相应的变换关系。在参与运算时他们之间的差距通常非常小，但却是不同角度下的描述，因此正确的理解并区分他们是必要的。</p>
<pre><code class="language-python"># mindspore base moudel import
import numpy as np
import mindspore
from mindspore import ops
from mindspore import Tensor, CSRTensor, COOTensor
print('moudel import success')
</code></pre>
<pre><code>moudel import success
</code></pre>
<h3>a base tensor create</h3>
<p>构造张量时，支持传入Tensor、float、int、bool、tuple、list、complex和numpy.ndarray类型。</p>
<ol>
<li>根据数据直接生成
可以根据数据创建张量，数据类型可以设置或者通过框架自动推断。</li>
</ol>
<pre><code class="language-python"># python原生类型
int_tensor = Tensor(1)
float_tensor = Tensor(1.)
bool_tensor = Tensor(True)
tuple_tensor = Tensor((1,2))
list_tensor = Tensor([1,3])
complex_tensor = Tensor(complex(1,9))
temp_dict = locals()
for k,v in temp_dict.items():
    if k.endswith('tensor') and isinstance(v, Tensor):
        print(
            k, 
            ';value is :', v,
            ';shape is :', v.shape,
            ';dtype is :', v.dtype
        )
# Tensor、numpy.ndarray类型
nd_tensor = Tensor(np.array([[1,2],[3,4]], dtype=np.float32))
print('nd_tensor', id(nd_tensor), nd_tensor.shape, nd_tensor.dtype)
cp_tensor = Tensor(nd_tensor)
print('cp_tensor', id(cp_tensor), cp_tensor.shape, cp_tensor.dtype)
</code></pre>
<pre><code>int_tensor ;value is : 1 ;shape is : () ;dtype is : Int64
float_tensor ;value is : 1.0 ;shape is : () ;dtype is : Float32
bool_tensor ;value is : True ;shape is : () ;dtype is : Bool
tuple_tensor ;value is : [1 2] ;shape is : (2,) ;dtype is : Int64
list_tensor ;value is : [1 3] ;shape is : (2,) ;dtype is : Int64
complex_tensor ;value is : (1+9j) ;shape is : () ;dtype is : Complex128
nd_tensor 281468910652768 (2, 2) Float32
cp_tensor 281468910653168 (2, 2) Float32
</code></pre>
<ol start="2">
<li>使用init初始化器构造张量</li>
</ol>
<p>当使用init初始化器对张量进行初始化时，支持传入的参数有init、shape、dtype。</p>
<ul>
<li>
<p>init: 支持传入initializer的子类。如：下方示例中的 One() 和 Normal()。</p>
</li>
<li>
<p>shape: 支持传入 list、tuple、 int。</p>
</li>
<li>
<p>dtype: 支持传入mindspore.dtype。</p>
</li>
</ul>
<pre><code class="language-python">from mindspore.common.initializer import One, Normal

# Initialize a tensor with ones
tensor1 = mindspore.Tensor(shape=(2, 2), dtype=mindspore.float32, init=One())
print(&quot;tensor1:\n&quot;, tensor1)
</code></pre>
<pre><code>tensor1:
 [[1. 1.]
 [1. 1.]]
</code></pre>
<p>Normal初始化器会将数据进行正太分布处理，公式如下:
$f(x) =  \frac{1} {\sqrt{2<em>π} * sigma}exp(-\frac{(x - mean)^2} {2</em>{sigma}^2})$
参数默认值 sigma=0.01, mean=0.0，生成的x元素为随机值</p>
<pre><code class="language-python"># Initialize a tensor from normal distribution
tensor2 = mindspore.Tensor(shape=(2, 3), dtype=mindspore.float32, init=Normal())
print(&quot;tensor2:\n&quot;, tensor2)
</code></pre>
<pre><code>tensor2:
 [[ 0.01408593  0.00398565  0.01824992]
 [-0.00208053  0.01520424  0.01576259]]
</code></pre>
<blockquote>
<p>在我探究Normal()作用时，注意到另一个和 <code>mindspore.Tensor</code> 类似的类 <code>mindspore._c_expression.Tensor</code>,那么他们有什么区别呢？</p>
</blockquote>
<blockquote>
<p>为了解决这个问题，我编写了以下python代码验证：</p>
</blockquote>
<pre><code class="language-python">from mindspore._c_expression import Tensor as Tensor_
import mindspore._c_expression as _c
# 这个_c_expression是一个so库文件，可以通过__file__属性查看其所在位置
print('the _c_expression so library file path is :', _c.__file__)
some_list = []  # 记载Tensor_和Tensor自身属性地址相同部分
diff_list = []
for k in dir(Tensor_):
    if k.startswith('__'): continue
    if id(getattr(Tensor_, k)) == id(getattr(Tensor,k)):
        some_list.append(k)
    else:
        diff_list.append(k)
print('-' * 20)
print('mindspore.Tensor and mindspore._c_expression.Tensor has some attrs is :',
      ' '.join(some_list))
print('all some attrs nums is :', len(some_list))
print('-' * 20)
print('mindspore.Tensor and mindspore._c_expression.Tensor has diff attrs is :',
       ' '.join(diff_list))
print('all diff attrs nums is :', len(diff_list))
</code></pre>
<pre><code>the _c_expression so library file path is : /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages/mindspore/_c_expression.cpython-39-aarch64-linux-gnu.so
--------------------
mindspore.Tensor and mindspore._c_expression.Tensor has some attrs is : _dtype _flatten_tensors _flush_from_cache _get_flattened_tensors _get_fusion_size _is_flattened _is_test_stub _itemsize _nbytes _shape _size _strides adapter_flag assign_value_cpp data_sync dim getitem_index_info init_flag is_init offload offload_file_path param_info persistent_data_from_numpy set_cast_dtype set_dtype set_init_flag setitem_index_info
all some attrs nums is : 27
--------------------
mindspore.Tensor and mindspore._c_expression.Tensor has diff attrs is : _offload asnumpy asnumpy_of_slice_persistent_data contiguous dtype from_numpy get_bytes is_contiguous is_persistent_data shape
all diff attrs nums is : 10
</code></pre>
<p>可以看到Tensor_和Tensor大部分属性的均指向同一地址，因为_c_expression是一个库扩展模块，要想更加详细的了解他们之间区别，需要去查看对应的c++源码实现。
这里只列出部分我探究的内容，更详细的解析请自行查看源码。</p>
<!-- TODO 未完成，仅列出部分以记录 -->
<ol>
<li>python类Tensor的init方法在<code>mindspore\python\mindspore\common\tensor.py</code>;在其初始化方法中最终均会调用<code>Tensor_.__init__</code>方法</li>
<li>mindspore编写python扩展<code>_c_expression</code>是通过<code>pybind11</code>进行的，在<code>mindspore\ccsrc\CMakeLists.txt</code>文件中存在调用<code>pybind11_add_module</code>的cmake宏进行py模块绑定，对应文件为<code>mindspore\ccsrc\pipeline\jit\ps\init.cc</code>，内有<code>PYBIND11_MODULE(_c_expression, m)</code> 进行<code>_c_expression</code>模块的具体代码绑定。</li>
<li>第2步中，<code>_c_expression</code>模块缺少py::class Tensor的绑定，我只在<code>mindspore\ccsrc\pybind_api\ir\tensor_py.cc</code>中找到 <code>mindspore.Tensor</code> 的绑定代码。</li>
<li>进一步研究发现，<code>tensor_py.cc</code>对应的<code>py::class Tensor</code>绑定代码在函数<code>RegMetaTensor</code>中，会被<code>RegModule</code>调用，最终在<code>PYBIND11_MODULE</code>中通过<code>mindspore::RegModuleHelper</code>调用绑定，而<code>mindspore.Tensor</code>继承自<code>_c_expression.Tensor</code>类，可以通过类的mro方法查看继承关系。</li>
</ol>
<pre><code class="language-python">print(Tensor.mro())
print(Tensor_.mro())
</code></pre>
<pre><code>[&lt;class 'mindspore.common.tensor.Tensor'&gt;, &lt;class 'mindspore._c_expression.Tensor'&gt;, &lt;class 'mindspore._c_expression.MetaTensor'&gt;, &lt;class 'pybind11_builtins.pybind11_object'&gt;, &lt;class 'object'&gt;]
[&lt;class 'mindspore._c_expression.Tensor'&gt;, &lt;class 'mindspore._c_expression.MetaTensor'&gt;, &lt;class 'pybind11_builtins.pybind11_object'&gt;, &lt;class 'object'&gt;]
</code></pre>
<pre><code class="language-python"># 回到正题，张量Tensor的创建也可以根据另一个Tensor的属性进行
# mindspore提供了一个ops模块可用于Cell的构造
a_ones = ops.ones_like(tensor1)
a_zeros = ops.zeros_like(tensor1)
print('ops create ones tensor is:', a_ones)
print('ops create zeros tensor is:', a_zeros)
</code></pre>
<pre><code>ops create ones tensor is: [[1. 1.]
 [1. 1.]]
ops create zeros tensor is: [[0. 0.]
 [0. 0.]]
</code></pre>
<h3>张量的常用属性</h3>
<ul>
<li>
<p>形状（shape）：<code>Tensor</code>的shape，是一个tuple。</p>
</li>
<li>
<p>数据类型（dtype）：<code>Tensor</code>元素的dtype，是MindSpore的一个数据类型。</p>
</li>
<li>
<p>单个元素大小（itemsize）： <code>Tensor</code>中每一个元素占用字节数，是一个整数。</p>
</li>
<li>
<p>占用字节数量（nbytes）： <code>Tensor</code>占用的总字节数，是一个整数。</p>
</li>
<li>
<p>维数（ndim）： <code>Tensor</code>的秩，也就是len(tensor.shape)，是一个整数。</p>
</li>
<li>
<p>元素个数（size）： <code>Tensor</code>中所有元素的个数，是一个整数。</p>
</li>
<li>
<p>每一维步长（strides）： <code>Tensor</code>每一维所需要的字节数，是一个tuple。</p>
</li>
</ul>
<pre><code class="language-python">t = Tensor([[1,2,3],[1,7,9]])
print(&quot;t_shape:&quot;, t.shape)
print(&quot;t_dtype:&quot;, t.dtype)
print(&quot;t_itemsize:&quot;, t.itemsize)
print(&quot;t_nbytes:&quot;, t.nbytes)
print(&quot;t_ndim:&quot;, t.ndim)
print(&quot;t_size:&quot;, t.size)
print(&quot;t_strides:&quot;, t.strides)
</code></pre>
<pre><code>t_shape: (2, 3)
t_dtype: Int64
t_itemsize: 8
t_nbytes: 48
t_ndim: 2
t_size: 6
t_strides: (24, 8)
</code></pre>
<p><span display=hidden>### 维度与维数区别
Tensorflow描述张量的维度：阶，形状以及维数</p>
<p>TensorFlow用张量这种数据结构来表示所有的数据.你可以把一个张量想象成一个n维的数组或列表.一个张量有一个静态类型和动态类型的维数.张量可以在图中的节点之间流通。</p>
<p>在TensorFlow系统中，张量的维数来被描述为阶。但是张量的阶和矩阵的阶并不是同一个概念。张量的阶（有时是关于如顺序或度数或者是n维）是张量维数的一个数量描述。</p>
<p>比如，下面的张量（使用Python中list定义的）就是2阶。</p>
<p>TensorFlow文档中使用了三种记号来方便地描述张量的维度：阶，形状以及维数.下表展示了他们之间的关系：
</span></p>
<h3>张量索引</h3>
<p>Tensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号:和 ...用于对数据进行切片。</p>
<pre><code class="language-python">print('the tensor is:', t)
print(&quot;First row: {}&quot;.format(t[0]))
print(&quot;value of bottom right corner: {}&quot;.format(t[1, 1]))
print(&quot;Last column: {}&quot;.format(t[:, -1]))
print(&quot;First column: {}&quot;.format(t[..., 0]))
</code></pre>
<pre><code>the tensor is: [[1 2 3]
 [1 7 9]]
First row: [1 2 3]
value of bottom right corner: 7
Last column: [3 9]
First column: [1 1]
</code></pre>
<h3>张量运算</h3>
<p>张量之间可以使用很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，使用方法和numpy类似</p>
<pre><code class="language-python">x = Tensor(np.array([9, 2, 3, 5]), mindspore.float32)
y = Tensor(np.array([4, 5, 6, 3]), mindspore.float32)
# 1. 算术运算
print(&quot;add:&quot;, x + y)
print(&quot;sub:&quot;, x - y)
print(&quot;mul:&quot;, x * y)
print(&quot;div:&quot;, x / y)
print(&quot;mod:&quot;, x % y)
print(&quot;floordiv:&quot;, x // y)
# 2. 矩阵处理
print(&quot;转置:&quot;, x.reshape((2,2)).T)
# 使用`ops.concat`连接张量
print(&quot;concat tensors:&quot;, ops.concat((x, y), axis=0))
# 使用ops.stack从新维度合并张量
print(&quot;stack tensors:&quot;, ops.stack([x,y]))
# 3. tensor与np.ndarray转换
print(f&quot;x: {x}&quot;, type(x))
n = x.asnumpy()
print(f&quot;n: {n}&quot;, type(n))

</code></pre>
<pre><code>add: [13.  7.  9.  8.]
sub: [ 5. -3. -3.  2.]
mul: [36. 10. 18. 15.]
div: [2.25      0.4       0.5       1.6666666]
mod: [1. 2. 3. 2.]
floordiv: [2. 0. 0. 1.]
[[9. 3.]
 [2. 5.]]
concat tensors: [9. 2. 3. 5. 4. 5. 6. 3.]
stack tensors: [[9. 2. 3. 5.]
 [4. 5. 6. 3.]]
x: [9. 2. 3. 5.] &lt;class 'mindspore.common.tensor.Tensor'&gt;
n: [9. 2. 3. 5.] &lt;class 'numpy.ndarray'&gt;
</code></pre>
<h3>几种特殊tensor</h3>
<h4>稀疏张量</h4>
<p>稀疏张量中绝大部分元素的值为零。</p>
<p>在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。</p>
<p>MindSpore支持常用的<code>CSR</code>和<code>COO</code>两种稀疏数据格式，如<code>CSRTensor</code>、<code>COOTensor</code>和<code>RowTensor</code>等</p>
<p>常用稀疏张量的表达形式是<code>&lt;indices:Tensor, values:Tensor, shape:Tensor&gt;</code>。其中，<code>indices</code>表示非零下标元素， <code>values</code>表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。</p>
<h5>CSRTensor</h5>
<p><code>CSR</code>（Compressed Sparse Row，压缩稀疏行）稀疏张量格式有着高效的存储与计算的优势。其中，非零元素的值存储在<code>values</code>中，非零元素的位置存储在<code>indptr</code>（行）和<code>indices</code>（列）中。各参数含义如下：</p>
<ul>
<li>
<p><code>indptr</code>: 一维整数张量, 表示稀疏数据每一行的非零元素在<code>values</code>中的起始位置和终止位置, 索引数据类型支持int16、int32、int64。</p>
</li>
<li>
<p><code>indices</code>: 一维整数张量，表示稀疏张量非零元素在列中的位置, 与<code>values</code>长度相等，索引数据类型支持int16、int32、int64。</p>
</li>
<li>
<p><code>values</code>: 一维张量，表示<code>CSRTensor</code>相对应的非零元素的值，与<code>indices</code>长度相等。</p>
</li>
<li>
<p><code>shape</code>: 表示被压缩的稀疏张量的形状，数据类型为<code>Tuple</code>，目前仅支持二维<code>CSRTensor</code>。</p>
</li>
</ul>
<p><strong>注意</strong> CSRTensor有以下限制：</p>
<ol>
<li>CSR仅能表示二维张量</li>
<li>行张量<code>indptr</code>的<code>size</code>为<code>csrtensor.shape[0]+1</code>，其索引i表示csr张量第i行，值为列张量<code>indices</code>索引，即指向该行第一个非0元素列位置</li>
<li>列张量<code>indices</code>，存储每个非0元素的列位置，长度与值张量<code>values</code>相等，<code>indices[i]</code> 表示第i个非0元素所在列位置</li>
<li>值张量<code>values</code> 存储csr所有非0值，按先行后列排序</li>
</ol>
<p><strong>注意</strong> 在Ascend平台，CSRTensor很多运算不可用</p>
<pre><code class="language-python">indptr = Tensor([0, 2, 4], dtype=mindspore.int32)
indices = Tensor([0, 2, 1, 3], dtype=mindspore.int32)
values = Tensor([1, 5, 2, 9], dtype=mindspore.float32)
shape = (2, 4)

# Make a CSRTensor
csr_tensor = CSRTensor(indptr, indices, values, shape)

print(csr_tensor.astype(mindspore.float64).dtype)
print(csr_tensor)
# 第一行元素indptr[0]首个非零元素在indices[indptr[0]]列出现，值为values[indptr[0]]
# 第二行元素indptr[1]首个非零元素在indices[indptr[1]]列出现，值为values[indptr[1]]
# values[indptr[0],indptr[1]]为第一行所有非零元素，列位置在indices中
</code></pre>
<pre><code>Float64
CSRTensor(shape=[2, 4], dtype=Float32, indptr=Tensor(shape=[3], dtype=Int32, value=[0 1 2]), indices=Tensor(shape=[4], dtype=Int32, value=[0 2 1 3]), values=Tensor(shape=[4], dtype=Float32, value=[ 1.00000000e+00  5.00000000e+00  2.00000000e+00  9.00000000e+00]))
</code></pre>
<p>上述代码表示如下所示的<code>CSRTensor</code>:</p>
<p>$$
\left[
\begin{matrix}
1 &amp; 0 &amp; 5 &amp; 0 \
0 &amp; 2 &amp; 0 &amp; 9
\end{matrix}
\right]
$$</p>
<h5>COOTensor</h5>
<p><code>COO</code>（Coordinate Format）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为<code>N</code>，被压缩的张量的维数为<code>ndims</code>。各参数含义如下：</p>
<ul>
<li>
<p><code>indices</code>: 二维整数张量，每行代表非零元素下标。形状：<code>[N, ndims]</code>， 索引数据类型支持int16、int32、int64。</p>
</li>
<li>
<p><code>values</code>: 一维张量，表示相对应的非零元素的值。形状：<code>[N]</code>。</p>
</li>
<li>
<p><code>shape</code>: 表示被压缩的稀疏张量的形状，目前仅支持二维<code>COOTensor</code>。</p>
</li>
</ul>
<p><strong>注意</strong> values中每个非零元素values[i]在COOTensor中的坐标为indices[i]，因此可支持多维Tensor</p>
<p>下面给出一些COOTensor的使用示例：</p>
<pre><code class="language-python">indices = Tensor([[0, 1], [1, 2]], dtype=mindspore.int32)
values = Tensor([1, 2], dtype=mindspore.float32)
shape = (3, 4)

# Make a COOTensor
COOTensor(indices, values, shape)

</code></pre>
<pre><code>COOTensor(shape=[3, 4], dtype=Float32, indices=Tensor(shape=[2, 2], dtype=Int32, value=
[[0 1]
 [1 2]]), values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))
</code></pre>
<p>上述代码表示如下所示的<code>COOTensor</code>:</p>
<p>$$
\left[
\begin{matrix}
0 &amp; 1 &amp; 0 &amp; 0 \
0 &amp; 0 &amp; 2 &amp; 0 \
0 &amp; 0 &amp; 0 &amp; 0
\end{matrix}
\right]
$$</p>
<pre><code class="language-python">from datetime import datetime
import pytz
print(datetime.now(pytz.timezone('Asia/Shanghai')), '\nuser:YZSH-HSZY')
</code></pre>
<pre><code>2024-07-04 16:08:16.273507+08:00 
user:YZSH-HSZY
</code></pre>

      </div><!-- /.entry-content -->

    </article>
  </section>
                <section id="extras" class="body">
                                <div class="blogroll">
                                        <h2>links</h2>
                                        <ul>
                                                        <li><a href="https://getpelican.com/">Pelican</a></li>
                                                        <li><a href="https://www.python.org/">Python.org</a></li>
                                                        <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                                                        <li><a href="#">You can modify those links in your config file</a></li>
                                        </ul>
                                </div><!-- /.blogroll -->
                                <div class="social">
                                        <h2>social</h2>
                                        <ul>
                                                        <li><a href="https://yzsh-hszy.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                                                        <li><a href="#">You can add links in your config file</a></li>
                                                        <li><a href="#">Another social link</a></li>
                                        </ul>
                                </div><!-- /.social -->
                </section><!-- /#extras -->

                <footer id="contentinfo" class="body">
                        <address id="about" class="vcard body">
                                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                        </address><!-- /#about -->

                        <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
                </footer><!-- /#contentinfo -->

        </body>
</html>