<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Welcome to YZSH-HSZY blog. - YZSH-HSZY</title><link href="https://yzsh-hszy.github.io/" rel="alternate"/><link href="https://yzsh-hszy.github.io/feeds/yzsh-hszy.atom.xml" rel="self"/><id>https://yzsh-hszy.github.io/</id><updated>2025-09-10T12:00:00+08:00</updated><entry><title>Compile SQLCipher Using MSVC</title><link href="https://yzsh-hszy.github.io/2025-09-10-compile-sqlcipher-using-msvc.html" rel="alternate"/><published>2025-09-10T12:00:00+08:00</published><updated>2025-09-10T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2025-09-10:/2025-09-10-compile-sqlcipher-using-msvc.html</id><summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;记录使用 &lt;code&gt;MSVC&lt;/code&gt; 编译器编译 &lt;code&gt;SQLCipher&lt;/code&gt; 这个加密&lt;code&gt;SQLite&lt;/code&gt;扩展项目的笔记&lt;/p&gt;
&lt;h2&gt;准备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ActiveTcl&lt;/code&gt;: 一个Tcl/Tk 发行版, 开箱即用(SQLCipher需要tclsh用于生产源代码和测试)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OpenSSL&lt;/code&gt;: SQLCipher使用的加密后端&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文档:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/sqlcipher/sqlcipher"&gt;sqlcipher官方仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://discuss.zetetic.net/c/sqlcipher/5?page=3"&gt;sqlcipher社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://platform.activestate.com/ActiveState/ActiveTcl-8.6"&gt;ActiveTcl下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;编 …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;记录使用 &lt;code&gt;MSVC&lt;/code&gt; 编译器编译 &lt;code&gt;SQLCipher&lt;/code&gt; 这个加密&lt;code&gt;SQLite&lt;/code&gt;扩展项目的笔记&lt;/p&gt;
&lt;h2&gt;准备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ActiveTcl&lt;/code&gt;: 一个Tcl/Tk 发行版, 开箱即用(SQLCipher需要tclsh用于生产源代码和测试)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OpenSSL&lt;/code&gt;: SQLCipher使用的加密后端&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文档:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/sqlcipher/sqlcipher"&gt;sqlcipher官方仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://discuss.zetetic.net/c/sqlcipher/5?page=3"&gt;sqlcipher社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://platform.activestate.com/ActiveState/ActiveTcl-8.6"&gt;ActiveTcl下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;编译&lt;/h2&gt;
&lt;p&gt;以&lt;code&gt;4.1.0&lt;/code&gt;版本&lt;code&gt;SQLCipher&lt;/code&gt;为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备 &lt;code&gt;openssl 1.1.x&lt;/code&gt; 库, &lt;code&gt;ActiveTcl&lt;/code&gt;包(&lt;code&gt;sqlcipher&lt;/code&gt;使用&lt;code&gt;tcl&lt;/code&gt;生成部分源码和测试)&lt;/li&gt;
&lt;li&gt;拉取 &lt;code&gt;sqlcipher&lt;/code&gt; 源码并切换到4.1.0&lt;/li&gt;
&lt;li&gt;修改 &lt;code&gt;Makefile.msc&lt;/code&gt; 添加&lt;code&gt;TCC&lt;/code&gt;/&lt;code&gt;RCC&lt;/code&gt;/&lt;code&gt;LTLINKOPTS&lt;/code&gt;的额外选项, 如下所示&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;TCC = $(TCC) -DSQLITE_HAS_CODEC -DSQLITE_TEMP_STORE=2 -IC:\opt\openssl-1.1.1d-x64\include
RCC = $(RCC) -DSQLITE_HAS_CODEC -DSQLITE_TEMP_STORE=2 -IC:\opt\openssl-1.1.1d-x64\include
LTLINKOPTS = $(LTLINKOPTS) /LIBPATH:C:\opt\openssl-1.1.1d-x64\lib libcrypto.lib
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;nmake -f Makefile.msc&lt;/code&gt; 编译所有目标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同sqlcipher版本支持的openssl-api不一致, 可根据changelog查看对应支持&lt;/li&gt;
&lt;li&gt;&lt;code&gt;4.1.0&lt;/code&gt; 版本只需要开启 &lt;code&gt;SQLITE_HAS_CODEC&lt;/code&gt; 宏即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sqlite3 :memory: &amp;quot;PRAGMA cipher_version;&amp;quot;&lt;/code&gt; 查看sqlcipher版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sqlite3 :memory: &amp;quot;SELECT sqlite_version();&amp;quot;&lt;/code&gt; 查看对应的sqlite版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sqlite3 :memory: &amp;quot;PRAGMA compile_options;&amp;quot;&lt;/code&gt; 查看编译选项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 加解密的&lt;code&gt;key&lt;/code&gt;(密码)/&lt;code&gt;cipher_compatibility&lt;/code&gt;(加密版本)/&lt;code&gt;kdf_iter&lt;/code&gt;(密钥迭代次数)/&lt;code&gt;cipher&lt;/code&gt;(加密方法) 都必须一致, 才能正确解密&lt;/p&gt;
&lt;h3&gt;使用C-API操作db&lt;/h3&gt;
</content><category term="SQLCipher"/></entry><entry><title>QTableView Multi-Key Sort</title><link href="https://yzsh-hszy.github.io/2025-09-01-qtableview-multi-key-sort.html" rel="alternate"/><published>2025-09-01T12:00:00+08:00</published><updated>2025-09-01T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2025-09-01:/2025-09-01-qtableview-multi-key-sort.html</id><summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;在Qt的Tableview中让数据按多个指定项有序, 类似基数排序&lt;/p&gt;
&lt;h2&gt;key固定, 不会动态更改排序key&lt;/h2&gt;
&lt;h3&gt;使用自定义model实现静态多key有序&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;继承 &lt;code&gt;QAbstractTableModel&lt;/code&gt; 实现自定义&lt;code&gt;TableModel&lt;/code&gt;
重写以下方法:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-cpp"&gt;QVariant data(const QModelIndex&amp;amp; index, int role = Qt::DisplayRole …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;在Qt的Tableview中让数据按多个指定项有序, 类似基数排序&lt;/p&gt;
&lt;h2&gt;key固定, 不会动态更改排序key&lt;/h2&gt;
&lt;h3&gt;使用自定义model实现静态多key有序&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;继承 &lt;code&gt;QAbstractTableModel&lt;/code&gt; 实现自定义&lt;code&gt;TableModel&lt;/code&gt;
重写以下方法:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-cpp"&gt;QVariant data(const QModelIndex&amp;amp; index, int role = Qt::DisplayRole) const override;
int rowCount(const QModelIndex &amp;amp;parent = QModelIndex()) const override;
int columnCount(const QModelIndex &amp;amp;parent = QModelIndex()) const override;
QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;QMap&lt;/code&gt; 存储实际数据
使用自定义 &lt;code&gt;POD&lt;/code&gt; 类型作为 &lt;code&gt;QMap&lt;/code&gt; 的key, 并重载 &lt;code&gt;openator&amp;lt;&lt;/code&gt; 函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;%%writefile main.cpp

struct TableModelMapKey {
    int first;
    int sencond;
    int trhird;
    bool operator&amp;lt;(const TableModelMapKey&amp;amp; o) const {
        if (first != o.first) return first &amp;lt; o.first;
        else if (sencond != o.sencond) return sencond &amp;lt; o.sencond;
        else if (trhird != o.trhird) return trhird &amp;lt; o.trhird;
        return false;
    }
};
QMap&amp;lt;TableModelMapKey, QString&amp;gt; _m_datas;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Overwriting main.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;QMap定义为Template, 其中key&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-cpp"&gt;template &amp;lt;class Key, class T&amp;gt;
class QMap
{
    typedef QMapNode&amp;lt;Key, T&amp;gt; Node;

    QMapData&amp;lt;Key, T&amp;gt; *d;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;!g++ main.cpp `PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/smartwork/work/qtbase-69ce741c186c9a1dd4ea9eecb7a51725c4e62342/install/lib/pkgconfig pkg-config --libs --cflags Qt6Core` -o main.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;!LD_LIBRARY_PATH=/home/smartwork/work/qtbase-69ce741c186c9a1dd4ea9eecb7a51725c4e62342/install/lib/ ./main.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Hello World!
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;%%time
import os

print(os.getcwd())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/home/smartwork/work/mblog/qt
CPU times: user 0 ns, sys: 450 μs, total: 450 μs
Wall time: 463 μs
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Qt"/></entry><entry><title>Linux SSH Port Forward Example.</title><link href="https://yzsh-hszy.github.io/2025-03-20-linux-ssh-port-forward-example.html" rel="alternate"/><published>2025-03-20T12:00:00+08:00</published><updated>2025-03-20T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2025-03-20:/2025-03-20-linux-ssh-port-forward-example.html</id><summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;此文章记录使用ssh进行端口转发的示例。&lt;/p&gt;
&lt;p&gt;ssh能够将其他tcp端口的网络数据通ssh连接来转发, 并且提供自动加密及解密服务, 也叫做tunnel(隧道). 如&lt;code&gt;Telnet&lt;/code&gt;/&lt;code&gt;SMTP&lt;/code&gt;/&lt;code&gt;LDAP&lt;/code&gt;等应用.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ssh隧道优点:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;避免了用户名,密码及隐私信 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;此文章记录使用ssh进行端口转发的示例。&lt;/p&gt;
&lt;p&gt;ssh能够将其他tcp端口的网络数据通ssh连接来转发, 并且提供自动加密及解密服务, 也叫做tunnel(隧道). 如&lt;code&gt;Telnet&lt;/code&gt;/&lt;code&gt;SMTP&lt;/code&gt;/&lt;code&gt;LDAP&lt;/code&gt;等应用.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ssh隧道优点:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;避免了用户名,密码及隐私信息的明文传输&lt;/li&gt;
&lt;li&gt;突破防火墙的一些限制进行tcp连接&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/469638489"&gt;知乎-ssh端口转发(跳板机)实战详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;本地转发&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;ssh -g -L 6013:192.168.8.16:6013 -fN 192.168.8.14
将所有连接到*:6013的连接转发到192.168.8.16:6013, 通过与192.168.8.14的ssh隧道
# Options:
    -g 允许远程主机连接到本地转发端口,此时监听地址为 &amp;quot;0.0.0.0:local_port&amp;quot; 不带-g选项则为 &amp;quot;127.0.0.1:local_port&amp;quot;
    -L [bind_address:]port:host:hostport
        指定到本地(客户端)主机上给定tcp_port/unix_socket的连接将被转发到远程端的给定主机和tcp_port/unix_socket。(即所有连接本地port的连接被转发到远程port)
        这是通过分配一个套接字来监听本地端的TCP端口（可选地绑定到指定的绑定地址）或Unix套接字来实现的。每当连接到本地端口或套接字时，该连接就会通过安全通道转发，并从远程计算机连接到主机端口hostport或Unix套接字远程套接字。
    -f  请求ssh在命令执行之前进入后台. 如果ssh将要询问密码或密码短语,但用户希望它在后台执行.这意味着-n(即重定向stdin到/dev/null)
    -N  不执行远程命令, 在进行端口转发时比较有用. 一版的ssh连接执行login_shell(如/bin/bash)命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;远程转发&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ssh -R 6666:192.168.8.14:22 -fN admin@192.168.8.16
将连接到远程主机上给定TCP端口(192.168.8.16:6666)的连接转发到本地端(192.168.8.14:22)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;双层x11转发&lt;/h2&gt;
&lt;p&gt;private-host &lt;code&gt;ssh -L 6015:192.100.1.104:6015 -fN localhost&lt;/code&gt;
middle-host &lt;code&gt;ssh -g -L 6015:192.168.8.16:6015 -fN localhost&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时可以在private-host上运行x11-app转发到192.168.8.16上显示&lt;/p&gt;
</content><category term="Linux"/></entry><entry><title>Linux Root File System Make.</title><link href="https://yzsh-hszy.github.io/2025-03-15-linux-root-file-system-make.html" rel="alternate"/><published>2025-03-15T12:00:00+08:00</published><updated>2025-03-15T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2025-03-15:/2025-03-15-linux-root-file-system-make.html</id><content type="html">&lt;h1&gt;笔记介绍&lt;/h1&gt;
&lt;p&gt;此文件记载我学习定制linux系统中关于 &lt;code&gt;root file system&lt;/code&gt; 的部分&lt;/p&gt;
&lt;h2&gt;参考文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.cnblogs.com/wsg1100/p/13127636.html"&gt;博客园-制作ubuntu-base rootfs博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content><category term="Linux"/></entry><entry><title>Customize Virtual Device Using Qemu.</title><link href="https://yzsh-hszy.github.io/2025-03-10-customize-virtual-device-using-qemu.html" rel="alternate"/><published>2025-03-10T12:00:00+08:00</published><updated>2025-03-10T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2025-03-10:/2025-03-10-customize-virtual-device-using-qemu.html</id><summary type="html">&lt;h1&gt;笔记介绍&lt;/h1&gt;
&lt;p&gt;该博客用于记录学习在qemu中添加自定义开发板的过程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; qemu 官方在 &lt;code&gt;hw/misc/edu.c&lt;/code&gt; 中提供了一个教学用的设备样例, 可参考此文件实现模拟设 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;笔记介绍&lt;/h1&gt;
&lt;p&gt;该博客用于记录学习在qemu中添加自定义开发板的过程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; qemu 官方在 &lt;code&gt;hw/misc/edu.c&lt;/code&gt; 中提供了一个教学用的设备样例, 可参考此文件实现模拟设备创建.&lt;/p&gt;
&lt;h2&gt;QEMU Object Model&lt;/h2&gt;
&lt;p&gt;在 qemu 中使用一套叫做 &lt;code&gt;Qemu Object Model&lt;/code&gt; 的东西来实现面向对象式开发模拟设备，主要由这四个组件构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type：用来定义一个「类」的基本属性，例如类的名字、大小、构造函数等&lt;/li&gt;
&lt;li&gt;Class：用来定义一个「类」的静态内容，例如类中存储的静态数据、方法函数指针等&lt;/li&gt;
&lt;li&gt;Object：动态分配的一个「类」的具体的实例（instance），储存类的动态数据&lt;/li&gt;
&lt;li&gt;Property：动态对象数据的访问器（accessor），可以通过监视器接口进行检查&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一个定义设备obj的示例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;static void pci_edu_register_types(void)
{
    static InterfaceInfo interfaces[] = {
        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
        { },
    };
    static const TypeInfo edu_info = {
        .name          = TYPE_PCI_EDU_DEVICE,
        .parent        = TYPE_PCI_DEVICE,
        .instance_size = sizeof(EduState),
        .instance_init = edu_instance_init,
        .class_init    = edu_class_init,
        .interfaces = interfaces,
    };
    type_register_static(&amp;amp;edu_info);
}
type_init(pci_edu_register_types)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;QEMU添加设备流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;hw/{target_architecture}/&lt;/code&gt; 下, 创建新设备定义文件&lt;/li&gt;
&lt;li&gt;实例化虚拟设备的 &lt;code&gt;TypeInfo&lt;/code&gt;, 并提供 &lt;code&gt;type_register_static&lt;/code&gt; 注册, &lt;code&gt;type_init&lt;/code&gt; 调用&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;TypeInfo&lt;/code&gt; 设备obj的 &lt;code&gt;class_init&lt;/code&gt; class初始函数指针, 对于模拟开发板, 在&lt;code&gt;class_init&lt;/code&gt;指定的方法中需要实例化&lt;code&gt;MACHINE_CLASS&lt;/code&gt;并配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;QEMU API介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type_init&lt;/code&gt; 宏, 会被扩展为&lt;code&gt;gcc attribute constructor&lt;/code&gt;修饰的函数&lt;code&gt;do_qemu_init_##&lt;/code&gt;函数, 此属性修饰的函数会在程序的&lt;code&gt;main()&lt;/code&gt;函数之前自动调用, 其最终的作用是将一个 &lt;code&gt;TypeInfo&lt;/code&gt; 结构体实例通过  &lt;code&gt;type_register_static&lt;/code&gt; 函数注册到 &lt;code&gt;GHashTable&lt;/code&gt; 中&lt;/li&gt;
&lt;/ul&gt;
</content><category term="Qemu"/></entry><entry><title>Build Mini Linux Distro And Use Qemu Running.</title><link href="https://yzsh-hszy.github.io/2025-02-10-build-mini-linux-distro-and-use-qemu-running.html" rel="alternate"/><published>2025-02-10T12:00:00+08:00</published><updated>2025-02-10T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2025-02-10:/2025-02-10-build-mini-linux-distro-and-use-qemu-running.html</id><summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;这是使用qemu的使用教程, 以构建最小linux发行版为例.
&lt;a href="https://github.com/nir9/welcome/tree/master"&gt;参nir9博客&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;术语参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;initrd&lt;/code&gt;: 初始化RAM磁盘, 是在实际根文件系统之前装载的初始根文件系统. initrd绑定到内核时会被内核引导过程加载,然后挂载 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;这是使用qemu的使用教程, 以构建最小linux发行版为例.
&lt;a href="https://github.com/nir9/welcome/tree/master"&gt;参nir9博客&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;术语参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;initrd&lt;/code&gt;: 初始化RAM磁盘, 是在实际根文件系统之前装载的初始根文件系统. initrd绑定到内核时会被内核引导过程加载,然后挂载initrd以加载模块使真正的文件系统可用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpio&lt;/code&gt;: cpio是一个将文件复制到 cpio 或 tar 存档文件或从中复制文件的程序,存档可以是磁盘上的另一个文件/磁带/管道&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;从构建linux内核开始&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;env&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linux内核源码 &lt;code&gt;git clone --depth 1 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;依赖包 &lt;code&gt;apt install bzip2 libncurses-dev flex bison bc cpio libelf-dev libssl-dev syslinux dosfstools&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用qemu启动编译后的内核 &lt;code&gt;apt install qemu-system-x86&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要制作iso镜像文件 &lt;code&gt;apt install isolinux genisoimage&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 在linux目录下使用 &lt;code&gt;make help&lt;/code&gt; 查看帮助, 这里我们使用 &lt;code&gt;make tinyconfig&lt;/code&gt; 配置尽可能小的内核&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;make menuconfig&lt;/code&gt; 配置编译make选项, 配置如下:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;64-bit kernel
General setup  ---&amp;gt;Initial RAM filesystem and RAM disk (initramfs/initrd) support 
General setup  ---&amp;gt;Configure standard kernel features (expert users)  ---&amp;gt;Enable support for printk 
Executable file formats  ---&amp;gt;Kernel support for ELF binaries 
Device Drivers  ---&amp;gt;Character devices  ---&amp;gt;Enable TTY
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;以上配置分别代表生成 &lt;code&gt;64位内核&lt;/code&gt;;&lt;code&gt;启用RAM文件系统和初始化根文件系统&lt;/code&gt;;&lt;code&gt;启用文本打印支持&lt;/code&gt;;&lt;code&gt;支持ELF格式执行文件&lt;/code&gt;;&lt;code&gt;启用tty字符设备&lt;/code&gt;
使用 &lt;code&gt;make -j $(nproc)&lt;/code&gt; 构建, 默认生成的内核镜像在 &lt;code&gt;arch/x86/boot/bzImage&lt;/code&gt;,为压缩的kernel镜像,约780K
查看内核镜像的运行 &lt;code&gt;qemu-system-x86_64 --kernel arch/x86/boot/bzImage&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 此时qemu启动kernel会显示 &lt;code&gt;not working init found&lt;/code&gt;, 因为此时没有准备启动初始程序&lt;/p&gt;
&lt;h2&gt;构建一个mini-shell&lt;/h2&gt;
&lt;p&gt;上述步骤中, 我们完成了一个轻量式的linux-kernel构建,接下来准备构建一个轻量的shell来作为init程序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写一个简易的调用shell命令程序, 使用POISX接口&lt;code&gt;write/read/execve/waitid&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

int main(){
    char cmd[255];
    for(;;){
        write(1, &amp;quot;# &amp;quot;, 2);
        int count = read(0, cmd, 255);
        // write(1, &amp;quot;&amp;quot;, );
        cmd[count - 1] = 0;
        pid_t child = fork();
        if (child == -1){
            write(1, &amp;quot;fork failed!\nexit!!!&amp;quot;, 21);
            break;
        }
        if (child == 0){
            execve(cmd, 0, NULL);
            break;
        }
        siginfo_t infop;
        waitid(P_ALL, 0, &amp;amp;infop, WEXITED);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;code&gt;gcc -static shell.c -o init&lt;/code&gt; 编译为静态可执行文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo init | cpio -H newc -o &amp;gt; init.cpio&lt;/code&gt; 生成一个initrd&lt;/li&gt;
&lt;li&gt;重新编译为iso内核 &lt;code&gt;make isoimage FDARGS=&amp;quot;initrd=/init.cpio&amp;quot; FDINITRD=$(pwd)/init.cpio&lt;/code&gt; 生成的arch/x96/boot/image.iso 镜像大小为2.2M&lt;/li&gt;
&lt;li&gt;启动iso镜像 &lt;code&gt;qemu-system-x86_64 -cdrom image.iso&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;使用assembly进行系统调用,进一步精简init程序&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;此过程需要的参考文档资源如下:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在linux源码目录下参考系统调用的id号 &lt;code&gt;linux/arch/x86/include/generated/asm/syscalls_64.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查阅&lt;a href="https://www.intel.cn/content/www/cn/zh/support/articles/000006715/processors.html"&gt;inter x86开发手册&lt;/a&gt;了解各寄存器作用, 这里仅关注rax寄存器用于存储syscall的id&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/X86_calling_conventions"&gt;wiki x86 体系结构的调用约定&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;准备待链接的.c和.s源文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;// shell.c
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

int real_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options, void*);

int main()
{
	char command[255];
	for (;;) {
		write(1, &amp;quot;# &amp;quot;, 2);
		int count = read(0, command, 255);
		// /bin/ls\n -&amp;gt; /bin/ls\0
		command[count - 1] = 0;
		pid_t fork_result = fork();
		if (fork_result == 0) {
			execve(command, 0, 0);
			break;
		} else {
			// wait
			// 
			siginfo_t info;
			real_waitid(P_ALL, 0, &amp;amp;info, WEXITED, 0);
		}
	}

	_exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-asm"&gt;sys.S
.intel_syntax noprefix

.global write
.global read
.global fork
.global execve
.global real_waitid
.global _exit

write:
mov rax, 1
syscall
ret

read:
mov rax, 0
syscall
ret

execve:
mov rax, 59
syscall
ret


fork:
mov rax, 57
syscall
ret

real_waitid:
mov rax, 247
mov r10, rcx
syscall
ret

_exit:
mov rax, 60
syscall
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;为什么 &lt;code&gt;real_waitid&lt;/code&gt; 函数多了一条 &lt;code&gt;mov r10, rcx&lt;/code&gt;指令?&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href="https://en.wikipedia.org/wiki/X86_calling_conventions"&gt;wiki x86 体系结构的调用约定&lt;/a&gt;
AMD64架构下gcc编译器使用的参数寄存器依次是 &lt;code&gt;Integer/pointer arguments(RDI, RSI, RDX, RCX, R8, R9), Floating point arguments([XYZ]MM0–7)&lt;/code&gt;.
而内核接口使用的参数寄存器是 &lt;code&gt;RDI, RSI, RDX, R10, R8 and R9&lt;/code&gt;
因此在汇编实现的syscall function需要将第四个参数从寄存器RCX移动到R10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;依次执行编译链接命令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gcc -c shell.c -o shell.o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as sys.S -o sys.o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ld -o init shell.o sys.o --entry main -z noexecstack&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;code&gt;Segmentation fault&lt;/code&gt; 问题排查&lt;/h4&gt;
&lt;p&gt;上述步骤中生成的最小init,在我调用时报错 &lt;code&gt;Segmentation fault (core dumped)&lt;/code&gt;, 在我进一步排查积累了以下经验&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先, 我想验证通过gcc和as链接obj生成程序是否可行, 而不是其他版本或库等的问题. 为此我编写了一个仅包含&lt;code&gt;write&lt;/code&gt;的系统调用和对应的asm实现syscall id寄存器(此处是eax/rax)的装载
示例代码如下:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// shell.c
#include &amp;lt;unistd.h&amp;gt;

int main(){
    write(1, &amp;quot;# &amp;quot;, 2);
}
// sys.S
.intel_syntax noprefix

.global write

write:
mov rax, 1
syscall
ret
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;但是我仍得到了 &lt;code&gt;Segmentation fault&lt;/code&gt;,不同的是在此之前程序有期望的输出&lt;code&gt;# &lt;/code&gt;, 此时想要继续探究下去, 我就需要探索汇编了, 但这方面我不太熟悉, 因此消耗了一些时间. 首先因为具有期望输出, 使用判断此时asm系统调用应该可用, 了解到 &lt;code&gt;objdump&lt;/code&gt; 这一反汇编工具, 因此将生成的程序反汇编 &lt;code&gt;objdump -D minit &amp;gt; mm.S&lt;/code&gt; , 主要关注syscall之后的部分&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;0000000000401000 &amp;lt;main&amp;gt;:
  401019:	e8 07 00 00 00       	callq  401025 &amp;lt;write&amp;gt;
  40101e:	b8 00 00 00 00       	mov    $0x0,%eax
  401023:	5d                   	pop    %rbp
  401024:	c3                   	retq   

0000000000401025 &amp;lt;write&amp;gt;:
  401025:	48 c7 c0 01 00 00 00 	mov    $0x1,%rax
  40102c:	0f 05                	syscall 
  40102e:	c3                   	retq   
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;可以看到在 &lt;code&gt;call write&lt;/code&gt; 之后仅有指令:常量mov和pop栈恢复, 判断应该是此处有问题, 让我们通过gdb调试一下  &lt;code&gt;gdb minit&lt;/code&gt;; 在gdb命令界面中输入 &lt;code&gt;set disassemble-next-line on&lt;/code&gt; 开启自动反汇编; &lt;code&gt;layout regs -tui&lt;/code&gt; 以tui形式显示寄存器; &lt;code&gt;si&lt;/code&gt;逐步汇编指令调试, 发现在执行 &lt;code&gt;retq&lt;/code&gt; 时报 &lt;code&gt;cannot access memory at address 0x1&lt;/code&gt;, 因此我们需要避免gcc为我们自动处理的退出, 这也是为什么需要使用&lt;code&gt;_exit&lt;/code&gt; syscall来退出程序, 在&lt;code&gt;sys.S&lt;/code&gt;中添加_exit定义后,此部分工作正常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start="3"&gt;
&lt;li&gt;
&lt;p&gt;现在，让我们用上述步骤调试 &lt;code&gt;init&lt;/code&gt; 程序中的 &lt;code&gt;Segmentation fault&lt;/code&gt;, 问题发生在 &lt;code&gt;mov %fs:0x28, %rax&lt;/code&gt;, 查阅资料得知, 此部分用于栈溢出保护,一般和指令 &lt;code&gt;mov %rax, -0x8(%rsp)&lt;/code&gt; 配套出现, 其作用为:从线程局部空间随机读取一个值, 在函数返回时, 检查此值是否被修改, 以防止栈溢出攻击. 在64bit模式下 %fs 的实际基址由 %fs_base 决定, 此值为0, 因此出现了非法地址范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我推断这部分应该时gcc自动完成的部分, 在上述进行仅包含 &lt;code&gt;write&lt;/code&gt; syscall 的init程序时调试时, 并没有这部分. 经过步步裁剪, 栈溢出保护由语句 &lt;code&gt;siginfo_t info;&lt;/code&gt; 引入, siginfo_t在进行临时变量拷贝时, 可能有值溢出, 因此我推测引入&lt;code&gt;siginfo_t&lt;/code&gt;时gdb自动添加栈溢出保护语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定位到问题, 那么就不能使用带 &lt;code&gt;siginfo_t&lt;/code&gt; 参数的 &lt;code&gt;waitid&lt;/code&gt; syscall了, 我尝试使用 &lt;code&gt;waitpid&lt;/code&gt; 找到其syscall为&lt;code&gt;syscall_wait4(61)&lt;/code&gt;, 工作正常&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这里, 我犯了个低级问题, 在asm中实现的waitpid忘记加ret返回, 程序在执行一次子进程后自动退出, 因为PC在执行waitpid后, 自动+1执行到_exit指令位置致循环失效, 主进程退出, 因为涉及到多个进程和无限循环, 导致我又绕了一大圈.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start="6"&gt;
&lt;li&gt;最后让我们查看一下 &lt;code&gt;init&lt;/code&gt; 的大小并重新生成iso镜像, &lt;code&gt;du -sh init image.iso // 12K, 1.9M&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</content><category term="Qemu"/></entry><entry><title>multiprocess blog.</title><link href="https://yzsh-hszy.github.io/2024-12-30-multiprocess-blog.html" rel="alternate"/><published>2024-12-30T19:00:00+08:00</published><updated>2024-12-30T19:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-12-30:/2024-12-30-multiprocess-blog.html</id><summary type="html">&lt;h1&gt;笔记介绍&lt;/h1&gt;
&lt;p&gt;该笔记用于记录工作中多进程相关问题和学习笔记.主要为python语言.
&lt;a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html"&gt;参阅官方多进程文档获取详细说明&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;python内部提供一个multiprocessing模块, 其支持使 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;h1&gt;笔记介绍&lt;/h1&gt;
&lt;p&gt;该笔记用于记录工作中多进程相关问题和学习笔记.主要为python语言.
&lt;a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html"&gt;参阅官方多进程文档获取详细说明&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;python内部提供一个multiprocessing模块, 其支持使用与 threading 模块类似的 API 来操作进程。可用其来绕过GIL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os
from os.path import splitext, join, dirname, basename, abspath
import multiprocessing

print(f&amp;quot;current ipynb path is: {os.getcwd()}&amp;quot;)
print(f&amp;quot;mkdir cache dir in order to run py in shell&amp;quot;)

os.makedirs('.cache', exist_ok=True)

print(f&amp;quot;\ncreate dir {join(os.getcwd(), '.cache')} success.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;current ipynb path is: /home/smartwork/work/mblog/process
mkdir cache dir in order to run py in shell

create dir /home/smartwork/work/mblog/process/.cache success.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; multiprocessing 需要能够通过 &lt;code&gt;__main__&lt;/code&gt; 模块加载target, 因此在一些交互式环境中无法使用.如在 jupyter 中无法运行, 可使用外置shell执行 &lt;code&gt;!python &amp;lt;py_file&amp;gt;&lt;/code&gt;. 此处暂不深究repl中可加载 &lt;code&gt;__main__&lt;/code&gt; 但仍无法运行multiprocess&lt;/p&gt;
&lt;h2&gt;multiprocessing的支持上下文&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;spawn, 父进程启动一个新的python解释器进程. 子进程只继承运行进程对象的 run() 方法所必须的资源。&lt;/li&gt;
&lt;li&gt;fork, 在posix系统上可用.&lt;/li&gt;
&lt;li&gt;forkserver&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中,在window上默认使用 &lt;code&gt;spawn&lt;/code&gt; 方式启动&lt;/p&gt;
&lt;h2&gt;spawn探讨&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;%%writefile .cache/test_spwan.py
import multiprocessing

print(&amp;quot;import running output.&amp;quot;)

def spawn_example():
    print(f&amp;quot;{8**9}&amp;quot;)

if __name__ == &amp;quot;__main__&amp;quot;:
    multiprocessing.set_start_method('spawn', force=True)
    print(&amp;quot;current mp start method is: &amp;quot;,  multiprocessing.get_start_method())

    t = multiprocessing.Process(target=spawn_example)
    t.start()
    t.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Overwriting .cache/test_spwan.py
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;!python .cache/test_spwan.py
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;import running output.
current mp start method is:  spawn
import running output.
134217728
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上述执行结果中可以看到, &lt;code&gt;import running output.&lt;/code&gt; 输出了两次. 一次为python运行时解析执行的print语句,&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import collections
from dataclasses import dataclass
from enum import Enum
from functools import lru_cache
import math
import multiprocessing.context
import multiprocessing.pool
import multiprocessing.shared_memory
import multiprocessing.synchronize
from random import randint
import shutil
import struct
import os
from threading import Thread
from typing import Any, Dict, List, Optional, Tuple, Type, Union
from warnings import warn
import tqdm
from os.path import join, basename, dirname, splitext, isdir, isfile, isdir
from glob import glob

from math import pi as PI
from math import log, tan, atan, exp

from datetime import datetime
import numpy as np
import multiprocessing as mp
from multiprocessing.sharedctypes import Value, Array
from multiprocessing import Pool, Lock, Queue
import queue

from PyQt5.QtCore import QVariant
from qgis.core import QgsFeature, QgsGeometry, QgsPointXY, QgsProject, QgsApplication, QgsVectorLayer
from qgis.gui import QgisInterface
from qgis.utils import iface
from qgis._core import QgsCoordinateReferenceSystem, QgsFields, QgsField, QgsVectorFileWriter, QgsWkbTypes, QgsProject, QgsVectorLayer
from qgis._core import QgsApplication

def LonLat2WebMercator(lon, lat):
  &amp;quot;&amp;quot;&amp;quot;
    lonLat is from GPS's WGS84
    webMercator is the fromat in baidumap, googlemap
    longitude and latitude to web Mercator
  &amp;quot;&amp;quot;&amp;quot;
  x = lon*20037508.34/180
  y = log(tan((90+lat)*PI/360))/(PI / 180)
  y = y*20037508.34/180
  return [x, y]

def WebMercator2LonLat( x, y ):
  &amp;quot;&amp;quot;&amp;quot;
    web Mercator to longitude and latitude
  &amp;quot;&amp;quot;&amp;quot;
  lon = x/20037508.34*180
  lat = y/20037508.34*180
  lat = 180/PI*(2*atan(exp(lat*PI/180))-PI/2)
  return [lon, lat]

@dataclass
class A:
    i: int
    l: list
    d: dict

@dataclass
class Point:
    x: float
    y: float
    def to_qgs_geometry(self) -&amp;gt; QgsGeometry:
        return QgsGeometry.fromPointXY(QgsPointXY(*WebMercator2LonLat(self.x, self.y)))
    def handle_convert_geometry(self, 
            attrs: QgsFields, val_dicts: Dict[str, Any], layer: QgsVectorLayer = None) -&amp;gt; QgsGeometry:
        return self.to_qgs_geometry()

@dataclass
class Point25D:
    x: float
    y: float
    depth: float
    def to_qgs_geometry(self) -&amp;gt; QgsGeometry:
        return QgsGeometry.fromPointXY(QgsPointXY(*WebMercator2LonLat(self.x, self.y)))
    def handle_convert_geometry(self, 
            attrs: QgsFields, val_dicts: Dict[str, Any], layer: QgsVectorLayer = None) -&amp;gt; QgsGeometry:
        # if layer is not None: 
        #     layer.addAttribute(QgsField(&amp;quot;depth&amp;quot;, QVariant.String, None, 254))
        #     feature.setAttribute(&amp;quot;depth&amp;quot;, str(self.depth))
        if &amp;quot;depth&amp;quot; not in attrs.names(): 
            attrs.append(QgsField(&amp;quot;depth&amp;quot;, QVariant.String, None, 254))
        elif not val_dicts.get(&amp;quot;depth&amp;quot;, &amp;quot;&amp;quot;):
            # warn(f'Point25D 类型对应layer中, depth字段已存在,参{val_dicts},self.depth:{str(self.depth)}')
            pass
        else:
            warn(f'Point25D 类型对应layer中, depth字段已存在,参{val_dicts},self.depth:{str(self.depth)}')

        val_dicts['depth'] = str(self.depth)
        return self.to_qgs_geometry()

@dataclass
class Pline:
    minx: float
    miny: float
    maxx: float
    maxy: float
    points_number: int
    repeat_points: List[Point]
    def to_qgs_geometry(self) -&amp;gt; QgsGeometry:
        if self.points_number != len(self.repeat_points):
            warn(
                f&amp;quot;points_number is not equal to repeat_points, &amp;quot;
                f&amp;quot;points_number = {self.points_number}, repeat_points = {len(self.repeat_points)}&amp;quot;)
        return QgsGeometry.fromPolylineXY(
            [QgsPointXY(*WebMercator2LonLat(t.x, t.y)) for t in self.repeat_points]
        )
    def handle_convert_geometry(self, 
            attrs: QgsFields, val_dicts: Dict[str, Any], layer: QgsVectorLayer = None) -&amp;gt; QgsGeometry:
        return self.to_qgs_geometry()

MULT_POLYGON_COUNT = 0  # 多部分多边形计数

@dataclass
class Polygon:
    minx: float
    miny: float
    maxx: float
    maxy: float
    polygon_num: int
    repeat_plines: List[Pline]  # 不包含mixx/y,maxx/y
    def to_qgs_geometry(self) -&amp;gt; List[QgsGeometry]:
        if self.polygon_num != len(self.repeat_plines):
            warn(
                f&amp;quot;polygon_num is not equal to repeat_plines, &amp;quot;
                f&amp;quot;polygon_num = {self.polygon_num}, repeat_plines = {len(self.repeat_plines)}&amp;quot;)
        if self.polygon_num &amp;gt; 1:
            warn(
                f'handle multiple polygon. num is :{self.polygon_num}'
            )
        res = []
        for t in self.repeat_plines:
            res.append(QgsGeometry.fromPolygonXY(
                [[QgsPointXY(*WebMercator2LonLat(k.x, k.y)) for k in t.repeat_points]]
            ))
        return res
    def handle_convert_geometry(self, 
            attrs: QgsFields, val_dicts: Dict[str, Any], layer: QgsVectorLayer = None) -&amp;gt; QgsGeometry:
        global MULT_POLYGON_COUNT
        the_geoms = self.to_qgs_geometry()
        for polygon in the_geoms[1:]:
            MULT_POLYGON_COUNT += 1
            # Dat2Shp.add_feature_to_layer(-1, attrs, val_dicts, polygon, layer)
        return the_geoms[0]


def mp_handle_func(mp_queue: Queue):
    for i in range(1, 3):
        t = A(randint(1,10), [1,2], {})
        tt = randint(1,4) 
        if tt == 1:
            t = Point(1.2,2.4)
        if tt == 2:
            t = Polygon(0,1,2,3,1,[Pline(3,4,5,6,1,[Point(8,9)])])
        mp_queue.put(t)
    return mp.current_process().pid

if __name__ == &amp;quot;__main__&amp;quot;:
    multiprocessing.set_start_method('spawn')
    mp_queue = mp.Manager().Queue()
    
    a = A(1, [2,3], {'a':4})
    mp_queue.put(A)
    
    async_res: List[multiprocessing.pool.ApplyResult] = []
    
    with mp.Pool(2) as pool:
        pool: multiprocessing.pool.Pool
        async_res.append(pool.apply_async(mp_handle_func, args=(mp_queue, )))
        async_res.append(pool.apply_async(mp_handle_func, args=(mp_queue, )))
    
        [tem_p.wait() for tem_p in async_res]
    
    try:
        print([tem_p.get() for tem_p in async_res])
        while not mp_queue.empty():
            print(mp_queue.get_nowait())
    except queue.Empty as e:
        print('mp_queue is empty')
    pass

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[18952, 5852]
&amp;lt;class '__main__.A'&amp;gt;
A(i=9, l=[1, 2], d={})
A(i=7, l=[1, 2], d={})
Polygon(minx=0, miny=1, maxx=2, maxy=3, polygon_num=1, repeat_plines=[Pline(minx=3, miny=4, maxx=5, maxy=6, points_number=1, repeat_points=[Point(x=8, y=9)])])
A(i=4, l=[1, 2], d={})
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Test"/></entry><entry><title>Cpython Learen Notes.</title><link href="https://yzsh-hszy.github.io/2024-07-18-cpython-learen-notes.html" rel="alternate"/><published>2024-07-18T12:00:00+08:00</published><updated>2024-07-18T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-18:/2024-07-18-cpython-learen-notes.html</id><summary type="html">&lt;h1&gt;cpython&lt;/h1&gt;
&lt;p&gt;一个python的c语言解释器，同样的python解释器实现还有jython、pypy等&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/python/cpython"&gt;github官网&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;准备&lt;/h2&gt;
&lt;p&gt;在学习python的过程中，我对python的一些工作细节感到困惑，因此有了本文。在这里我将学习cpython源码的一些细节记录在下面:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt; cpython 3.12.3,ubuntu 20.04 in wsl2,gun/gcc系列编译器
&lt;strong&gt;注意&lt;/strong&gt; cpython在编译安装时，需 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;cpython&lt;/h1&gt;
&lt;p&gt;一个python的c语言解释器，同样的python解释器实现还有jython、pypy等&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/python/cpython"&gt;github官网&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;准备&lt;/h2&gt;
&lt;p&gt;在学习python的过程中，我对python的一些工作细节感到困惑，因此有了本文。在这里我将学习cpython源码的一些细节记录在下面:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt; cpython 3.12.3,ubuntu 20.04 in wsl2,gun/gcc系列编译器
&lt;strong&gt;注意&lt;/strong&gt; cpython在编译安装时，需要已有pyhton环境&lt;/p&gt;
&lt;h2&gt;cpython编译&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devguide.python.org/getting-started/setup-building/#build-dependencies"&gt;python官方开发构建文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在进行cpython的编译时，需要注意可能缺少相应的依赖项，可以使用&lt;code&gt;apt search&lt;/code&gt;和&lt;code&gt;apt-file&lt;/code&gt;命令找到包在机器上的安装名和文件存在与那些包中。&lt;/p&gt;
&lt;p&gt;这里列出一些需要的安装包&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;build-essential 包含一系列的C/C++开发工具，主要为GNU系列编译器&lt;/li&gt;
&lt;li&gt;python3-pip python的pip包管理器&lt;/li&gt;
&lt;li&gt;manpages-dev 适用于开发环境的man手册(包含系统调用和库调用的介绍信息)&lt;/li&gt;
&lt;li&gt;pkg-config 管理库的编译和链接标志的工具，在项目包含依赖库时有用&lt;/li&gt;
&lt;li&gt;cmake 一个简易的、生成makefile文件的项目构建工具&lt;/li&gt;
&lt;li&gt;gdb GNU系列的调试器，进行源码调试的工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 模块n/a(not available)有以下几种情况:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块不支持当前 Python 版本：某些模块可能只支持特定的 Python 版本，如果你使用的 Python 版本不在支持范围内，模块可能无法编译。&lt;/li&gt;
&lt;li&gt;缺少依赖库：某些模块可能依赖于特定的库或框架，如果这些库或框架未安装或不可用，模块可能无法编译。&lt;/li&gt;
&lt;li&gt;编译错误：模块的源代码可能存在错误，导致编译失败。&lt;/li&gt;
&lt;li&gt;不支持当前操作系统：某些模块可能只支持特定的操作系统，如果你使用的操作系统不在支持范围内，模块可能无法编译。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;编译过程&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;./configure --help  # 查看帮助信息
# 调试构建
mkdir debug
cd debug
../configure --with-pydebug
make
make test
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;configure文件生成&lt;/h4&gt;
&lt;p&gt;CPython 的 &lt;code&gt;configure&lt;/code&gt; 脚本是使用 &lt;code&gt;GNU Autoconf&lt;/code&gt; 从 &lt;code&gt;configure.ac&lt;/code&gt; 生成
你可以在更改 &lt;code&gt;configure.ac&lt;/code&gt; 后，运行 &lt;code&gt;make regen-configure&lt;/code&gt; 生成 &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;pyconfig.h.in&lt;/code&gt;/&lt;code&gt;aclocal.m4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 不同cpython版本使用的autoconf版本不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 Python 3.12 及更新版本，需要 &lt;code&gt;GNU Autoconf v2.71&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于 Python 3.11 及更早版本，需要 &lt;code&gt;GNU Autoconf v2.69&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;编译过程中报缺少模块的错误&lt;/h3&gt;
&lt;p&gt;一般是由于缺少头文件造成的，可以通过&lt;code&gt;find&lt;/code&gt;查看有无对应头文件，无则需要安装开发库，可通过&lt;code&gt;apt-file&lt;/code&gt;搜索可安装包，以下是一些模块对应缺少的依赖库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no module _ssl
安装tk-itk4-dev tcl-itcl4-dev libssl-dev&lt;/li&gt;
&lt;li&gt;ctype
libffi-dev&lt;/li&gt;
&lt;li&gt;readline
[libreadline-dev | lib32readline-dev]&lt;/li&gt;
&lt;li&gt;_bz2
libbz2-dev
介绍:
high-quality block-sorting file compressor library- development(高质量的块排序文件压缩程序库-开发)&lt;/li&gt;
&lt;li&gt;_lzma
liblzma-dev
介绍:
XZ-format compression library(xz格式的压缩算法库)
注意: 5.6.0,5.6.1版本中存在xz安全漏洞,请安装低版本&lt;/li&gt;
&lt;li&gt;_gdbm _dbm
libgdbm-dev libgdbm-compat-dev
介绍:
dbm: kv型数据库&lt;br /&gt;
libgdbm-dev: GNU dbm database routines(GNU数据库例程)
libgdbm-compat-dev: legacy support development files(遗留支持开发文件)。解决无dbm.h文件问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; &lt;code&gt;apt-file&lt;/code&gt;需要使用&lt;code&gt;apt install apt-file&lt;/code&gt;安装，并且使用&lt;code&gt;apt-file update&lt;/code&gt;更新数据库之后，才能使用。&lt;/p&gt;
&lt;h3&gt;使用 &lt;code&gt;dev container&lt;/code&gt; 进行 &lt;code&gt;cpython&lt;/code&gt; 的学习开发&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://code.visualstudio.com/docs/devcontainers/create-dev-container#_dockerfile"&gt;参vscode开发容器创建教程&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中 &lt;code&gt;devcontainer.json&lt;/code&gt; 可在cpython官方仓库中获取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;cpython目录结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Doc&lt;/code&gt;                 文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Grammar&lt;/code&gt;             包含 Python 的 EBNF(Extended Backus-Naur Form) 语法文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Include&lt;/code&gt;             cpython解释器头文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lib&lt;/code&gt;                 纯 Python 实现的标准库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Misc&lt;/code&gt;                独立目录，包含文档等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Modules&lt;/code&gt;             用 C 实现的标准库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Objects&lt;/code&gt;             所有内置类型的代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mac&lt;/code&gt;                 Mac 特定代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC&lt;/code&gt;                  Windows 特定代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PCbuild&lt;/code&gt;             MSVC 构建文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Parser&lt;/code&gt;              解析器相关的代码。包含 AST 节点定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Programs&lt;/code&gt;            C 可执行文件的源代码，包括 CPython 解释器的 main 函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Python&lt;/code&gt;              CPython core runtime。包括编译器、评估循环和各种内置模块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Tools&lt;/code&gt;               维护 Python 的工具&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;相关术语解释&lt;/h2&gt;
&lt;h3&gt;EBNF(Extended Backus-Naur Form, 扩展巴科斯范式)&lt;/h3&gt;
&lt;p&gt;巴科斯范式（Backus Normal Form简称为BNF），又称为巴科斯-诺尔范式，是一种上下文无关的语言，广泛地使用于程序设计语言、指令集、通信协议的语法表示中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上下文无关语言的典型代表: 正则语言 -- 一种通过有限状态机或正则表达式表达的语言，这种语言是上下文无关语言的子集。
一个表示数字相加的BNF示例如下:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;addition&amp;gt; ::= &amp;lt;number&amp;gt;+&amp;lt;number&amp;gt;
&amp;lt;number&amp;gt; ::= &amp;lt;sign&amp;gt;&amp;lt;integer&amp;gt;|&amp;lt;integer&amp;gt;
&amp;lt;integer&amp;gt; ::= &amp;lt;digit&amp;gt;|&amp;lt;digit&amp;gt;&amp;lt;integer&amp;gt;
&amp;lt;digit&amp;gt;::=0|1|2|3|4|5|6|7|8|9
&amp;lt;sign&amp;gt; ::= +|-
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;cpython源码分析&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;环境: Fedora Linux 40 ,clang version 18.1.8, Python 3.14.0a3+, git commit id: b00e1254fc, vscode devcontainer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由上述目录描述可知, Programs中存放的是 &lt;code&gt;CPython&lt;/code&gt; 解释器相关的实现部分, 其中 &lt;code&gt;python.c&lt;/code&gt; 定义了程序的入口&lt;/p&gt;
&lt;p&gt;当我们使用python执行脚本时, 从命令行中获取的参数会被 Modules/main.c 的 &lt;code&gt;Py_BytesMain&lt;/code&gt; 处理, 它会构建一个 &lt;code&gt;_PyArgv&lt;/code&gt; 类型的py参数封装, 并提供指针传递给 &lt;code&gt;pymain_main&lt;/code&gt; 调用, 在 &lt;code&gt;pymain_main&lt;/code&gt; 中py进行以下步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化py进程状态 &lt;code&gt;pymain_init&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_PyRuntime_Initialize(&amp;amp;_PyRuntime)&lt;/code&gt; 做一些运行初始化设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PyPreConfig_InitPythonConfig(&amp;amp;preconfig);&lt;/code&gt; 预处理py的配置信息,主要是编码方式、调试开关以及一些其他的命令选项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PyConfig_SetBytesArgv(&amp;amp;config, args-&amp;gt;argc, args-&amp;gt;bytes_argv);&lt;/code&gt; 设置py配置信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Py_InitializeFromConfig(&amp;amp;config);&lt;/code&gt; 根据配置信息初始化py全局设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PyConfig_Clear&lt;/code&gt; 清理局部解析的config对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果上一步的初始化正常，则调用 &lt;code&gt;Py_RunMain&lt;/code&gt; 会转动 &lt;code&gt;pymain_run_python&lt;/code&gt; 处理，其中会根据 &lt;code&gt;PyConfig *config&lt;/code&gt; 选择py的执行方式，有 &lt;code&gt;pymain_run_command/pymain_run_module/pymain_run_file/pymain_run_stdin&lt;/code&gt; 几种执行方式
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pymain_run_command&lt;/code&gt; 在使用 &lt;code&gt;python -c {COMMAND}&lt;/code&gt; 解释作为字符串传入的程序时执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; POSIX和WINDOWS的cpython的main入口的区别在于window上使用 &lt;code&gt;wchar_t*&lt;/code&gt; 来引用unicode参数&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hackmd.io/@klouielu/ByMHBMjFe?type=view"&gt;参使用gdb观察py对象的构建&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
Downloading separate debug info for system-supplied DSO at 0x7ffd481b7000
Downloading separate debug info for /lib64/libm.so.6                                                                          
Downloading separate debug info for /lib64/libc.so.6                                                                          
[Thread debugging using libthread_db enabled]                                                                                 
Using host libthread_db library &amp;quot;/lib64/libthread_db.so.1&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://wiki.archlinux.org/title/Debugging/Getting_traces"&gt;参gdb获取调试栈信息&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;分析实例&lt;/h2&gt;
</content><category term="Cpython"/></entry><entry><title>Cpython Package Publish Notes.</title><link href="https://yzsh-hszy.github.io/2024-07-18-cpython-package-publish-notes.html" rel="alternate"/><published>2024-07-18T12:00:00+08:00</published><updated>2024-07-18T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-18:/2024-07-18-cpython-package-publish-notes.html</id><summary type="html">&lt;h2&gt;如何在 pypi(即python package index，python包索引)上发布自己新建的工具包？&lt;/h2&gt;
&lt;h3&gt;setup.cfg vs setup.py vs pyproject.toml区别&lt;/h3&gt;
&lt;p&gt;这三个文件是Python项目的配置文件,他们分别用于不同的目的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;setup.cfg: 这是 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h2&gt;如何在 pypi(即python package index，python包索引)上发布自己新建的工具包？&lt;/h2&gt;
&lt;h3&gt;setup.cfg vs setup.py vs pyproject.toml区别&lt;/h3&gt;
&lt;p&gt;这三个文件是Python项目的配置文件,他们分别用于不同的目的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;setup.cfg: 这是一个全局配置文件,它存储了用于构建、发布和安装Python包的选项。例如,您可以在此文件中指定需要安装的依赖项或构建选项。&lt;/li&gt;
&lt;li&gt;setup.py: 这是Python项目的关键配置文件,它包含了有关项目的信息,例如项目名称、版本、描述、作者等。您可以使用此文件来管理项目的构建、发布和安装过程。&lt;/li&gt;
&lt;li&gt;pyproject.toml: 这是Python项目的新标准配置文件,提供了一种更简洁、清晰的配置方式。
它可以用于描述项目的依赖项、构建选项、扩展等信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;总的来说,如果您正在开发一个新项目,建议使用pyproject.toml,因为它是Python项目的最新标准。
如果您正在开发一个旧项目,则可能需要使用setup.py和setup.cfg.&lt;/p&gt;
&lt;/blockquote&gt;
</content><category term="Cpython"/></entry><entry><title>Python Super Class Example Notes.</title><link href="https://yzsh-hszy.github.io/2024-07-18-python-super-class-example-notes.html" rel="alternate"/><published>2024-07-18T12:00:00+08:00</published><updated>2024-07-18T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-18:/2024-07-18-python-super-class-example-notes.html</id><summary type="html">&lt;h2&gt;super笔记&lt;/h2&gt;
&lt;p&gt;在oop编程中，我们经常需要使用super来调用父类的方法，各个编程语言均有对应的super实现。在python中提供超类super的类定义，有以下几种调用方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在类定义代码段中，使用无参数的 &lt;code&gt;super …&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h2&gt;super笔记&lt;/h2&gt;
&lt;p&gt;在oop编程中，我们经常需要使用super来调用父类的方法，各个编程语言均有对应的super实现。在python中提供超类super的类定义，有以下几种调用方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在类定义代码段中，使用无参数的 &lt;code&gt;super()&lt;/code&gt; 调用&lt;/li&gt;
&lt;li&gt;通过super通过的初始化方法 &lt;code&gt;super(type, object_or_type=None)&lt;/code&gt; 调用，该初始化方法有三种重载方法:
&lt;ul&gt;
&lt;li&gt;单参数 &lt;code&gt;super(type)&lt;/code&gt;,此时返回的super超类对象是未绑定的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;super(type, obj)&lt;/code&gt;,必须满足 &lt;code&gt;isinstance(obj,type)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;super(type, type2)&lt;/code&gt;,必须满足 &lt;code&gt;issubclass(type,type2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。 这对于访问已在类中被重写的继承方法很有用。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/zh-cn/3/library/functions.html#super"&gt;python官方super介绍&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;quot;&amp;quot;&amp;quot; 
    演示super(type, obj)和super(type,type2)调用
&amp;quot;&amp;quot;&amp;quot;
class Father:
    def father_obj_method(self):
        return 'this is obj of Father'
    @classmethod
    def father_classmethod(cls):
        return 'this is method of Father method'

class Child(Father):
    def father_obj_method(self):
        return 'overwrite obj method'
    @classmethod
    def father_classmethod(cls):
        return 'overwrite classmethod'

if __name__ == &amp;quot;__main__&amp;quot;:
    child_obj = Child()
    father_obj = Father()
    print('this is child obj`s method:', child_obj.father_obj_method())
    # 获取super代理对象，访问child_obj的父对象部分
    print('get child obj`s Father obj method:', super(Child, child_obj).father_obj_method())

    print('this is Child classmethod:', child_obj.father_classmethod())
    # 获取super代理对象，访问Child类的父类部分
    print('get Child class`s Father classmethod:', super(Child, Child).father_classmethod())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;this is child obj`s method: overwrite obj method
get child obj`s Father obj method: this is obj of Father
this is Child classmethod: overwrite classmethod
get Child class`s Father classmethod: this is method of Father method
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;super的父类查找顺序&lt;/h3&gt;
&lt;p&gt;在python官方文档中是这样描述的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;object_or_type 确定要用于搜索的解析顺序。 搜索会从 type 之后的类开始。
举例来说，如果 object_or_type 的 &lt;code&gt;__mro__&lt;/code&gt; 为 &lt;code&gt;D -&amp;gt; B -&amp;gt; C -&amp;gt; A -&amp;gt; object&lt;/code&gt; 并且 type 的值为 B，则 super() 将会搜索 &lt;code&gt;C -&amp;gt; A -&amp;gt; object&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;object_or_type 的 &lt;code&gt;__mro__&lt;/code&gt; 属性列出了 getattr() 和 super() 所共同使用的方法解析搜索顺序。 该属性是动态的并可在任何继承层级结构发生更新时被改变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; __mro__属性是被类方法mro()填充的，它在类实例化时被调用。即mro定义在元类type上，&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;type.mro
&amp;lt;method 'mro' of 'type' objects&amp;gt;
list.mro
&amp;lt;built-in method mro of type object at 0x00007FF9553BFAF0&amp;gt;
object.mro
&amp;lt;built-in method mro of type object at 0x00007FF9553C2E00&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-C"&gt;Python-3.12.3/Objects/typeobject.c :10147
typedef struct {
    PyObject_HEAD
    PyTypeObject *type;
    PyObject *obj;
    PyTypeObject *obj_type;
} superobject;

static PyMemberDef super_members[] = {
    {&amp;quot;__thisclass__&amp;quot;, T_OBJECT, offsetof(superobject, type), READONLY,
     &amp;quot;the class invoking super()&amp;quot;},
    {&amp;quot;__self__&amp;quot;,  T_OBJECT, offsetof(superobject, obj), READONLY,
     &amp;quot;the instance invoking super(); may be None&amp;quot;},
    {&amp;quot;__self_class__&amp;quot;, T_OBJECT, offsetof(superobject, obj_type), READONLY,
     &amp;quot;the type of the instance invoking super(); may be None&amp;quot;},
    {0}
};
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Cpython"/></entry><entry><title>Python Thread Package Example Notes.</title><link href="https://yzsh-hszy.github.io/2024-07-18-python-thread-package-example-notes.html" rel="alternate"/><published>2024-07-18T12:00:00+08:00</published><updated>2024-07-18T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-18:/2024-07-18-python-thread-package-example-notes.html</id><summary type="html">&lt;pre&gt;&lt;code class="language-python"&gt;import atexit
from datetime import datetime
import threading
from time import sleep
def test_p():
    print('this is test', str(datetime.now().strftime(&amp;quot;%d/%m/%Y, %H:%M:%S&amp;quot;)))
    assert 1 == 1
# atexit.register(test_p)
    
def thread_print():
    i = 0
    while i &amp;lt; 1e3:
        sleep(.001)
        i += 1
    print('threading end print')
def …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;pre&gt;&lt;code class="language-python"&gt;import atexit
from datetime import datetime
import threading
from time import sleep
def test_p():
    print('this is test', str(datetime.now().strftime(&amp;quot;%d/%m/%Y, %H:%M:%S&amp;quot;)))
    assert 1 == 1
# atexit.register(test_p)
    
def thread_print():
    i = 0
    while i &amp;lt; 1e3:
        sleep(.001)
        i += 1
    print('threading end print')
def end_print(*args):
    print('atexiting print')
    print(args)
    if isinstance(args[0], threading.Thread):
        p = args[0]
        print(p, p.is_alive(), p.name)
        p.join()
p = threading.Thread(
    target=thread_print,
    args=[]
)
# 1. 对应主进程来说，并不是主线程退出了，主进程就会退出
#   &amp;gt; 而是主进程会等待所有在前景的线程结束才会退出
# 2. 如果线程设置了守护标志，是一个背景线程daemon,那么主进程不会等待其执行完成才退出
#   &amp;gt; 一般无限循环检测标志或为其他线程提供服务的线程被设置为守护线程
# 
p.setDaemon(True)
p.start()
atexit.register(end_print, p)


&lt;/code&gt;&lt;/pre&gt;
</content><category term="Cpython"/></entry><entry><title>Python Unicode And Utf-8 Different Notes.</title><link href="https://yzsh-hszy.github.io/2024-07-18-python-unicode-and-utf-8-different-notes.html" rel="alternate"/><published>2024-07-18T12:00:00+08:00</published><updated>2024-07-18T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-18:/2024-07-18-python-unicode-and-utf-8-different-notes.html</id><summary type="html">&lt;pre&gt;&lt;code class="language-python"&gt;with open('all_unicode_char.txt', 'wb') as f:
    err_nums = 0
    true_nums = 0
    for i in range(1, pow(2, 19)):
        try:
            s = chr(i).encode('utf8')
        except UnicodeEncodeError:
            err_nums += 1
            s = None
        if s:
            f.write(s)
            true_nums += 1
    print(
        'the true add error nums equals range(1, pow(2,19 …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;pre&gt;&lt;code class="language-python"&gt;with open('all_unicode_char.txt', 'wb') as f:
    err_nums = 0
    true_nums = 0
    for i in range(1, pow(2, 19)):
        try:
            s = chr(i).encode('utf8')
        except UnicodeEncodeError:
            err_nums += 1
            s = None
        if s:
            f.write(s)
            true_nums += 1
    print(
        'the true add error nums equals range(1, pow(2,19)):',
        (err_nums + true_nums) == len(range(1,pow(2,19)))
    )

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;unicode中文范围
U4e00-u9fa5&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import re
# import jsonpath
# jsonpath.jsonpath(
#     {&amp;quot;l&amp;quot;:0,&amp;quot;tx&amp;quot;:{&amp;quot;b&amp;quot;:[8]},&amp;quot;b&amp;quot;:[1,2,9]},
#     &amp;quot;$..b[?(8 not in @)]&amp;quot;)
l=re.match('[\u4e00-\u9fa5 ]', '那就')
l=re.match(r'[\u4e00-\u9fa5 ]', '那就')
pp='xs'
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Cpython"/></entry><entry><title>Mindspore Learen Notes -- Data Transfroms Operation Learen.</title><link href="https://yzsh-hszy.github.io/2024-07-04-mindspore-learen-notes-data-transfroms-operation-learen.html" rel="alternate"/><published>2024-07-04T12:00:00+08:00</published><updated>2024-07-04T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-04:/2024-07-04-mindspore-learen-notes-data-transfroms-operation-learen.html</id><summary type="html">&lt;h1&gt;数据变换 Transforms&lt;/h1&gt;
&lt;p&gt;通常情况下，直接加载的原始数据并不能直接送入神经网络进行训练，我们需要对其进行数据预处理。MindSpore提供不同种类的数据变换（Transforms），配 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;数据变换 Transforms&lt;/h1&gt;
&lt;p&gt;通常情况下，直接加载的原始数据并不能直接送入神经网络进行训练，我们需要对其进行数据预处理。MindSpore提供不同种类的数据变换（Transforms），配合数据处理Pipeline来实现数据预处理。所有的Transforms均可通过&lt;code&gt;map&lt;/code&gt;方法传入，实现对指定数据列的处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset&lt;/code&gt;提供了面向图像、文本、音频等不同数据类型的Transforms，同时也支持使用Lambda函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np
from PIL import Image
from download import download
from mindspore.dataset import transforms, vision, text
from mindspore.dataset import GeneratorDataset, MnistDataset
print('base moudel import')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;base moudel import
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Common Transforms(常用变换)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset.transforms&lt;/code&gt;模块支持一系列通用Transforms。这里我们以&lt;code&gt;Compose&lt;/code&gt;为例，介绍其使用方式。&lt;/p&gt;
&lt;h3&gt;Compose(组合)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 接收一个序列，序列内存放各种数据增强操作，然后将这几个数据操作合并为单个数据操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 以MNIST数据集演示
# MNIST数据集下载
url = &amp;quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&amp;quot; \
      &amp;quot;notebook/datasets/MNIST_Data.zip&amp;quot;
path = download(url, &amp;quot;./&amp;quot;, kind=&amp;quot;zip&amp;quot;, replace=True)
train_dataset = MnistDataset('MNIST_Data/train')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Downloading data from https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/MNIST_Data.zip (10.3 MB)

file_sizes: 100%|██████████████████████████| 10.8M/10.8M [00:00&amp;lt;00:00, 58.3MB/s]
Extracting zip file...
Successfully downloaded / unzipped to ./
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 合并图像缩放和形状变换为一个操作
composed = transforms.Compose(
    [
        vision.Rescale(1.0 / 255.0, 0),
        vision.HWC2CHW()
    ]
)
# 原image的数据类型和shape
image, label = next(train_dataset.create_tuple_iterator())
print('before image shape and type is:', image.shape, image.dtype)
# 应用合并变换操作
train_dataset = train_dataset.map(composed, 'image')
image, label = next(train_dataset.create_tuple_iterator())
print('compose transforms image shape and type is:', image.shape, image.dtype)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;before image shape and type is: (28, 28, 1) UInt8
compose transforms image shape and type is: (1, 28, 28) Float32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上述输出中可以看到，image数据的shape、dtype均发生变化&lt;/p&gt;
&lt;h2&gt;Vision Transforms(视觉变换)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset.vision&lt;/code&gt; 模块提供一系列针对图像数据的Transforms。&lt;/p&gt;
&lt;h3&gt;Rescale(缩放)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Rescale&lt;/code&gt;变换用于调整图像像素值的大小，包括两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rescale：缩放因子。&lt;/li&gt;
&lt;li&gt;shift：平移因子。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图像的每个像素将根据这两个参数进行调整，输出的像素值为$output_{i} = input_{i} * rescale + shift$。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 这里我们先使用numpy随机生成一个像素值在[0, 255]的图像
random_np = np.random.randint(0, 255, (4, 4), np.uint8)
random_image = Image.fromarray(random_np)
print('src img data is:\n', random_np)

# 将其像素值进行缩放
rescale_image = vision.Rescale(rescale = 1.0 / 255.0, shift = 1)(random_image)
print('rescale img data is:\n', np.asarray(rescale_image))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;src img data is:
 [[205 201 102 194]
 [ 80 124 234 241]
 [ 27  62 151 131]
 [ 32 225  37 244]]
rescale img data is:
 [[1.8039216 1.7882353 1.4       1.7607844]
 [1.3137255 1.4862745 1.9176471 1.945098 ]
 [1.1058824 1.2431372 1.5921569 1.5137255]
 [1.1254902 1.882353  1.1450981 1.9568628]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Normalize(归一化)&lt;/h3&gt;
&lt;p&gt;变换用于对输入图像的归一化，包括三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mean：图像每个通道的均值，必须为一个序列，否则raise TypeError&lt;/li&gt;
&lt;li&gt;std：图像每个通道的标准差，必须为一个序列，否则raise TypeError&lt;/li&gt;
&lt;li&gt;is_hwc：bool值，表示输入图像是否为HWC格式， True 为HWC格式， False 为CHW格式。默认值： True。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图像的每个通道将根据&lt;code&gt;mean&lt;/code&gt;和&lt;code&gt;std&lt;/code&gt;进行调整，计算公式为$output_{c} = \frac{input_{c} - mean_{c}}{std_{c}}$，其中 $c$代表通道索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 以(0.2)作为序列，会自动卸包，而(0.2,)，[0.2]不会&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;normalize = vision.Normalize(mean=(0.1,), std=[0.3])
random_image = Image.fromarray(np.random.randint(0, 255, (2,3,4), np.uint8))  # hwc格式的rgba图像
normalized_image = normalize(random_image)
print(normalized_image)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[[[616.3333   186.33333  562.99994  699.6666  ]
  [802.99994  726.3333   123.        16.333332]
  [339.66666  582.99994    9.666667 406.3333  ]]

 [[ 29.666664 173.       739.6666   386.3333  ]
  [626.3333   109.666664 496.33328   46.333332]
  [652.99994  146.33333  809.6666   159.66667 ]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HWC2CHW&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HWC2CHW&lt;/code&gt;变换用于转换图像格式。在不同的硬件设备中可能会对(height, width, channel)或(channel, height, width)两种不同格式有针对性优化。MindSpore设置HWC为默认图像格式，在有CHW格式需求时，可使用该变换进行处理。&lt;/p&gt;
&lt;p&gt;图像进行转换，只转换shape。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;hwc_image = Image.fromarray(np.random.randint(0, 255, (2,3,4), np.uint8))  # hwc格式的rgba图像
chw_image = vision.HWC2CHW()(hwc_image)
print(np.array(hwc_image).shape, chw_image.shape)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(2, 3, 4) (4, 2, 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Text Transforms(文本变换)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset.text&lt;/code&gt;模块提供一系列针对文本数据的Transforms。与图像数据不同，文本数据需要有分词（Tokenize）、构建词表、Token转Index等操作。&lt;/p&gt;
&lt;p&gt;首先我们定义三段文本，作为待处理的数据，并使用&lt;code&gt;GeneratorDataset&lt;/code&gt;进行加载。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;texts = ['Welcome to Beijing']
test_dataset = GeneratorDataset(texts, 'text')
# 查看test_dataset中数据格式
text_tensor, = next(test_dataset.create_tuple_iterator())
print(text_tensor, type(text_tensor))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Welcome to Beijing &amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;PythonTokenizer(分词器)&lt;/h3&gt;
&lt;p&gt;分词（Tokenize）操作是文本数据的基础处理方法，MindSpore提供多种不同的Tokenizer。这里我们选择基础的&lt;code&gt;PythonTokenizer&lt;/code&gt;举例，它允许用户自由实现分词策略。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;test_dataset = test_dataset.map(text.PythonTokenizer(lambda v: v.split()))
print(next(test_dataset.create_tuple_iterator()))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[Tensor(shape=[3], dtype=String, value= ['Welcome', 'to', 'Beijing'])]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Lookup&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Lookup&lt;/code&gt;为词表映射变换，用来将Token转换为Index。在使用&lt;code&gt;Lookup&lt;/code&gt;前，需要构造词表，一般可以加载已有的词表，或使用&lt;code&gt;Vocab&lt;/code&gt;生成词表。这里我们选择使用&lt;code&gt;Vocab.from_dataset&lt;/code&gt;方法从数据集中生成词表。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;vocab = text.Vocab.from_dataset(test_dataset)
# 使用`vocab`方法查看词表
print(vocab.vocab())
# 生成词表后，即可通过Lookup操作进行词表映射变换，将Token转为Index
test_dataset = test_dataset.map(text.Lookup(vocab))
print(next(test_dataset.create_tuple_iterator()))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{'to': 2, 'Welcome': 1, 'Beijing': 0}
[Tensor(shape=[3], dtype=Int32, value= [1, 2, 0])]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Lambda Transforms&lt;/h2&gt;
&lt;p&gt;通过Lambda Transforms，用户对简单的变换操作可以自定义lambda函数实现，更灵活。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;test_dataset = GeneratorDataset([1, 2, 3], 'data', shuffle=False)
test_dataset = test_dataset.map(lambda x: x * 2)
print(list(test_dataset.create_tuple_iterator()))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[[Tensor(shape=[], dtype=Int64, value= 2)], [Tensor(shape=[], dtype=Int64, value= 4)], [Tensor(shape=[], dtype=Int64, value= 6)]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Audio Transforms(音频变换)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset.audio&lt;/code&gt;模块提供一系列针对音频数据的Transforms。&lt;a href="https://www.mindspore.cn/docs/zh-CN/r2.3.0/api_python/samples/dataset/audio_gallery.html"&gt;参audio文档&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 安装librosa库
import pip
pip.main(['install', 'librosa'])

import librosa
import numpy as np
import matplotlib.pyplot as plt
import scipy.io.wavfile as wavfile
from IPython.display import Audio
from download import download

import mindspore.dataset as ds
import mindspore.dataset.audio as audio
print('Audio环境准备')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;WARNING: pip is being invoked by an old script wrapper. This will fail in a future version of pip.
Please see https://github.com/pypa/pip/issues/5599 for advice on fixing the underlying issue.
To avoid this problem you can invoke Python with '-m pip' instead of running pip directly.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: librosa in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (0.10.2.post1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: audioread&amp;gt;=2.1.9 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (3.0.1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: numpy!=1.22.0,!=1.22.1,!=1.22.2,&amp;gt;=1.20.3 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.26.4)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: scipy&amp;gt;=1.2.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.13.1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: scikit-learn&amp;gt;=0.20.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.5.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: joblib&amp;gt;=0.14 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.4.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: decorator&amp;gt;=4.3.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (5.1.1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: numba&amp;gt;=0.51.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (0.60.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: soundfile&amp;gt;=0.12.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (0.12.1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: pooch&amp;gt;=1.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.8.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: soxr&amp;gt;=0.3.2 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (0.3.7)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: typing-extensions&amp;gt;=4.1.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (4.11.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: lazy-loader&amp;gt;=0.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (0.4)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: msgpack&amp;gt;=1.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.0.8)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: packaging in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from lazy-loader&amp;gt;=0.1-&amp;gt;librosa) (23.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: llvmlite&amp;lt;0.44,&amp;gt;=0.43.0dev0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from numba&amp;gt;=0.51.0-&amp;gt;librosa) (0.43.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: platformdirs&amp;gt;=2.5.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from pooch&amp;gt;=1.1-&amp;gt;librosa) (4.2.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: requests&amp;gt;=2.19.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from pooch&amp;gt;=1.1-&amp;gt;librosa) (2.32.3)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: threadpoolctl&amp;gt;=3.1.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from scikit-learn&amp;gt;=0.20.0-&amp;gt;librosa) (3.5.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: cffi&amp;gt;=1.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from soundfile&amp;gt;=0.12.1-&amp;gt;librosa) (1.16.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: pycparser in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from cffi&amp;gt;=1.0-&amp;gt;soundfile&amp;gt;=0.12.1-&amp;gt;librosa) (2.22)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: charset-normalizer&amp;lt;4,&amp;gt;=2 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from requests&amp;gt;=2.19.0-&amp;gt;pooch&amp;gt;=1.1-&amp;gt;librosa) (3.3.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: idna&amp;lt;4,&amp;gt;=2.5 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from requests&amp;gt;=2.19.0-&amp;gt;pooch&amp;gt;=1.1-&amp;gt;librosa) (3.7)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: urllib3&amp;lt;3,&amp;gt;=1.21.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from requests&amp;gt;=2.19.0-&amp;gt;pooch&amp;gt;=1.1-&amp;gt;librosa) (2.2.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: certifi&amp;gt;=2017.4.17 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from requests&amp;gt;=2.19.0-&amp;gt;pooch&amp;gt;=1.1-&amp;gt;librosa) (2024.6.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;
&lt;span style="font-weight: bold"&gt;[&lt;/span&gt;&lt;span style="color: #000080; text-decoration-color: #000080; background-color: #ffffff"&gt;notice&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff; font-weight: bold"&gt;]&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff"&gt; A new release of pip is available: &lt;/span&gt;&lt;span style="color: #800000; text-decoration-color: #800000; background-color: #ffffff"&gt;24.1&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff"&gt; -&amp;gt; &lt;/span&gt;&lt;span style="color: #008000; text-decoration-color: #008000; background-color: #ffffff"&gt;24.1.2&lt;/span&gt;
&lt;span style="font-weight: bold"&gt;[&lt;/span&gt;&lt;span style="color: #000080; text-decoration-color: #000080; background-color: #ffffff"&gt;notice&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff; font-weight: bold"&gt;]&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff"&gt; To update, run: &lt;/span&gt;&lt;span style="color: #008000; text-decoration-color: #008000; background-color: #ffffff"&gt;python -m pip install --upgrade pip&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Audio环境准备
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 下载音频wav文件
url = &amp;quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/84-121123-0000.wav&amp;quot;
download(url, './84-121123-0000.wav', replace=True)
wav_file = &amp;quot;84-121123-0000.wav&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Downloading data from https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/84-121123-0000.wav (65 kB)

file_sizes: 100%|██████████████████████████| 67.0k/67.0k [00:00&amp;lt;00:00, 25.9MB/s]
Successfully downloaded file to ./84-121123-0000.wav
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Spectrogram&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Spectrogram&lt;/code&gt; 用于从音频信号创建其频谱&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 读取音频文件
sample_rate, waveform = wavfile.read(wav_file)

def plot_waveform(waveform, sr, title=&amp;quot;Waveform&amp;quot;):
    &amp;quot;&amp;quot;&amp;quot; 绘制音频波形图 &amp;quot;&amp;quot;&amp;quot;
    if waveform.ndim == 1:
        waveform = waveform[np.newaxis, :]
    num_channels, num_frames = waveform.shape
    time_axis = np.arange(0, num_frames) / sr

    figure, axes = plt.subplots(num_channels, 1)
    axes.plot(time_axis, waveform[0], linewidth=1)
    axes.grid(True)
    figure.suptitle(title)
    plt.show(block=False)
    
def plot_spectrogram(specgram, title=None, ylabel=&amp;quot;freq_bin&amp;quot;):
    &amp;quot;&amp;quot;&amp;quot; 绘制音频光谱图 &amp;quot;&amp;quot;&amp;quot;
    fig, axs = plt.subplots(1, 1)
    axs.set_title(title or &amp;quot;Spectrogram (db)&amp;quot;)
    axs.set_ylabel(ylabel)
    axs.set_xlabel(&amp;quot;frame&amp;quot;)
    im = axs.imshow(librosa.power_to_db(specgram), origin=&amp;quot;lower&amp;quot;, aspect=&amp;quot;auto&amp;quot;)
    fig.colorbar(im, ax=axs)
    plt.show(block=False)

plot_waveform(waveform, sample_rate, title=&amp;quot;Original waveform&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/fourth-blog_files/fourth-blog_25_0.png" alt="png" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 进行Spectrogram变换
n_fft = 1024
win_length = None
hop_length = 512

# Define transform
spectrogram = audio.Spectrogram(
    n_fft=n_fft,
    win_length=win_length,
    hop_length=hop_length,
    center=True,
    pad_mode=audio.BorderType.REFLECT,
    power=2.0,
)

spec = spectrogram(waveform)
plot_spectrogram(spec, title=&amp;quot;audio&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/fourth-blog_files/fourth-blog_26_0.png" alt="png" /&gt;&lt;/p&gt;
&lt;h3&gt;GriffinLim&lt;/h3&gt;
&lt;p&gt;从线性幅度频谱图恢复信号波形&lt;/p&gt;
&lt;h3&gt;Mel Filter Bank&lt;/h3&gt;
&lt;p&gt;mindspore.dataset.audio.melscale_fbanks 可以创建频率变换矩阵。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from datetime import datetime
import pytz
print(datetime.now(pytz.timezone('Asia/Shanghai')), '\nuser:YZSH-HSZY')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2024-07-19 18:33:26.985327+08:00 
user:YZSH-HSZY
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Mindspore"/></entry><entry><title>Mindspore Learen Notes -- Construct Dataset.</title><link href="https://yzsh-hszy.github.io/2024-07-03-mindspore-learen-notes-construct-dataset.html" rel="alternate"/><published>2024-07-03T12:00:00+08:00</published><updated>2024-07-03T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-03:/2024-07-03-mindspore-learen-notes-construct-dataset.html</id><summary type="html">&lt;h2&gt;数据集 Dataset&lt;/h2&gt;
&lt;p&gt;数据是深度学习的基础，高质量的数据输入将在整个深度神经网络中起到积极作用。MindSpore提供基于Pipeline的数据引擎，通过数据集（Dataset）和数据变 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;数据集 Dataset&lt;/h2&gt;
&lt;p&gt;数据是深度学习的基础，高质量的数据输入将在整个深度神经网络中起到积极作用。MindSpore提供基于Pipeline的数据引擎，通过数据集（Dataset）和数据变换（Transforms）实现高效的数据预处理。其中Dataset是Pipeline的起始，用于加载原始数据。mindspore.dataset提供了内置的文本、图像、音频等数据集加载接口，并提供了自定义数据集加载接口。&lt;/p&gt;
&lt;p&gt;此外MindSpore的领域开发库也提供了大量的预加载数据集，可以使用API一键下载使用。&lt;/p&gt;
&lt;h3&gt;名词介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据引擎：用于将数据集高效、灵活的转换至Tensor，并将该Tensor提供给训练网络用于训练，mindspore数据引擎是将在深度学习过程中数据输入到网络这一中间环境给抽取出来的一个中间件，支持python或c++插件，支持多端数据处理。&lt;/li&gt;
&lt;li&gt;Transforms数据变换：通常情况下，直接加载的原始数据并不能直接送入神经网络进行训练，我们需要对其进行数据预处理。MindSpore提供一个用于不同种类的数据进行变换的通用层mindspore.dataset.transforms，配合数据处理Pipeline来实现数据预处理。所有的Transforms均可通过map方法传入，实现对指定数据列的处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np
import mindspore.dataset as ds
from mindspore.dataset import vision
from mindspore.dataset import MnistDataset, GeneratorDataset
import matplotlib.pyplot as plt
print('base moudle import')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;base moudle import
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据集加载&lt;/h3&gt;
&lt;p&gt;使用&lt;strong&gt;Mnist&lt;/strong&gt;数据集作为样例，介绍使用&lt;code&gt;mindspore.dataset&lt;/code&gt;进行加载的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; &lt;code&gt;mindspore.dataset&lt;/code&gt;提供的接口&lt;strong&gt;仅支持解压后的数据文件&lt;/strong&gt;，这里我们使用&lt;code&gt;download&lt;/code&gt;库下载数据集并解压。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# mnist数据集下载
from download import download

url = &amp;quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&amp;quot; \
      &amp;quot;notebook/datasets/MNIST_Data.zip&amp;quot;
path = download(url, &amp;quot;./&amp;quot;, kind=&amp;quot;zip&amp;quot;, replace=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Downloading data from https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/MNIST_Data.zip (10.3 MB)

file_sizes: 100%|███████████████████████████| 10.8M/10.8M [00:00&amp;lt;00:00, 154MB/s]
Extracting zip file...
Successfully downloaded / unzipped to ./
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 直接通过mindspore.dataset内置的MnistDataset类进行mnist数据加载
train_dataset = MnistDataset(&amp;quot;MNIST_Data/train&amp;quot;, shuffle=False)
print(type(train_dataset))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;class 'mindspore.dataset.engine.datasets_vision.MnistDataset'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据集迭代&lt;/h3&gt;
&lt;p&gt;数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。mindspore.dataset提供create_tuple_iterator和create_dict_iterator接口用于创建数据迭代器，迭代访问数据。&lt;/p&gt;
&lt;p&gt;访问的数据类型默认为&lt;code&gt;Tensor&lt;/code&gt;；若设置&lt;code&gt;output_numpy=True&lt;/code&gt;，访问的数据类型为&lt;code&gt;Numpy&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for idx, item in enumerate(train_dataset.create_tuple_iterator()):
    if idx == 1: break
    print(
        'the create_tuple_iterator generate`s iter length is :', len(item), 
        '\nthe iter item type is :', type(item),
        '\nelement in iter item type is :', [type(i) for i in item]
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;the create_tuple_iterator generate`s iter length is : 2 
the iter item type is : &amp;lt;class 'list'&amp;gt; 
element in iter item type is : [&amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;, &amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写可视化函数查看mnist手写数字识别数据集中图像数据&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def visualize(dataset):
    figure = plt.figure(figsize=(4, 4))
    cols, rows = 3, 3
    plt.subplots_adjust(wspace=0.5, hspace=0.5)
    for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):
        figure.add_subplot(rows, cols, idx + 1)
        plt.title(int(label))
        plt.axis(&amp;quot;off&amp;quot;)
        plt.imshow(image.asnumpy().squeeze(), cmap=&amp;quot;gray&amp;quot;)
        if idx == cols * rows - 1:
            break
    plt.show()
visualize(train_dataset)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/third-blog_files/third-blog_9_0.png" alt="png" /&gt;&lt;/p&gt;
&lt;h3&gt;数据集常用操作&lt;/h3&gt;
&lt;p&gt;Pipeline的设计理念使得数据集的常用操作采用&lt;code&gt;dataset = dataset.operation()&lt;/code&gt;的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。&lt;/p&gt;
&lt;h4&gt;shuffle&lt;/h4&gt;
&lt;p&gt;数据集随机&lt;code&gt;shuffle&lt;/code&gt;可以消除数据排列造成的分布不均问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset&lt;/code&gt;提供的数据集在加载时可配置&lt;code&gt;shuffle=True&lt;/code&gt;，或直接对数据集使用&lt;code&gt;shuffle&lt;/code&gt;方法获取新随机数据集&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 参数buffer_size必须，为进行数据重排时每行大小
train_dataset = train_dataset.shuffle(buffer_size=4)
visualize(train_dataset)
# 从下图中可以看到数据顺序发生变化
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/third-blog_files/third-blog_12_0.png" alt="png" /&gt;&lt;/p&gt;
&lt;h4&gt;map&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 如何查看数据集列名，可以通过create_dict_iterator的dict.keys集合获取
print('train_dataset columns name is:', next(train_dataset.create_dict_iterator()).keys())
image, label = next(train_dataset.create_tuple_iterator())
print('img data shape and type is:', image.shape, image.dtype)
print('label data shape and type is:', label.shape, label.dtype)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;train_dataset columns name is: dict_keys(['image', 'label'])
img data shape and type is: (28, 28, 1) UInt8
label data shape and type is: () UInt32
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from itertools import product
train_dataset = MnistDataset(&amp;quot;MNIST_Data/train&amp;quot;, shuffle=False)  # 重新加载数据集
image, label = next(train_dataset.create_tuple_iterator())
print('a image shape is:', image.shape)
# 查看第一张图片所有非零值
the_first_no_zeros_sign = False
the_first_no_zeros_index = None
for i in product(*[range(s) for s in image.shape]):
    if image.item(i):
        if not the_first_no_zeros_sign: 
            print('the first no zeros index is:', i)
            the_first_no_zeros_index, the_first_no_zeros_sign = i, True
            print('first image all no zeros', end=':')
        print(image.item(i), end='-')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;a image shape is: (28, 28, 1)
the first no zeros index is: (5, 12, 0)
first image all no zeros:3-18-18-18-126-136-175-26-166-255-247-127-30-36-94-154-170-253-253-253-253-253-225-172-253-242-195-64-49-238-253-253-253-253-253-253-253-253-251-93-82-82-56-39-18-219-253-253-253-253-253-198-182-247-241-80-156-107-253-253-205-11-43-154-14-1-154-253-90-139-253-190-2-11-190-253-70-35-241-225-160-108-1-81-240-253-253-119-25-45-186-253-253-150-27-16-93-252-253-187-249-253-249-64-46-130-183-253-253-207-2-39-148-229-253-253-253-250-182-24-114-221-253-253-253-253-201-78-23-66-213-253-253-253-253-198-81-2-18-171-219-253-253-253-253-195-80-9-55-172-226-253-253-253-253-244-133-11-136-253-253-253-212-135-132-16-
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 通过vision的视觉操作进行image列处理
train_dataset = MnistDataset(&amp;quot;MNIST_Data/train&amp;quot;, shuffle=False)  # 重新加载数据集
train_dataset = train_dataset.map(vision.Rescale(1.0 / 255.0, 0), input_columns='image')
image, label = next(train_dataset.create_tuple_iterator())
print('map op then first image shape and type is:', image.shape, image.dtype)
print('the first no zeros index is:', the_first_no_zeros_index)
print('the uint8 to float32 value is:', image.item(the_first_no_zeros_index))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;map op then first image shape and type is: (28, 28, 1) Float32
the first no zeros index is: (5, 12, 0)
the uint8 to float32 value is: 0.011764707
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;batch&lt;/h4&gt;
&lt;p&gt;将数据集打包为固定大小的&lt;code&gt;batch&lt;/code&gt;是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。&lt;/p&gt;
&lt;p&gt;一般我们会设置一个固定的batch size，将连续的数据分为若干批（batch）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; &lt;code&gt;batch&lt;/code&gt;操作后的数据增加一维，大小为&lt;code&gt;batch_size&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;train_dataset = train_dataset.batch(batch_size=4)
image, label = next(train_dataset.create_tuple_iterator())
print(image.shape, image.dtype)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(4, 28, 28, 1) Float32
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义数据集&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset&lt;/code&gt;模块提供了一些常用的公开数据集和标准格式数据集的加载API。&lt;/p&gt;
&lt;p&gt;对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过&lt;code&gt;GeneratorDataset&lt;/code&gt;接口实现自定义方式的数据集加载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GeneratorDataset&lt;/code&gt;支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可随机访问数据集&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可随机访问数据集是实现了&lt;code&gt;__getitem__&lt;/code&gt;和&lt;code&gt;__len__&lt;/code&gt;方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。&lt;/p&gt;
&lt;p&gt;例如，当使用&lt;code&gt;dataset[idx]&lt;/code&gt;访问这样的数据集时，可以读取dataset内容中第idx个样本或标签，该条数据可以通过GeneratorDataset接口转换为Tensor类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 可随机访问数据集在生成迭代Tensor组时，是随机获取的&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 可随机访问数据集，包含5组数据
class RandomAccessDataset:
    def __init__(self):
        self._data = np.eye(5, k=1)
        self._label = np.zeros((5, 1))

    def __getitem__(self, index):
        return self._data[index], self._label[index]

    def __len__(self):
        return len(self._data)
# 自定义数据集转换为mindspore可操作的dataset
loader = RandomAccessDataset()
dataset = GeneratorDataset(source=loader, column_names=[&amp;quot;data&amp;quot;, &amp;quot;label&amp;quot;])
# 数据随机
for data, label in dataset.create_tuple_iterator():
    print(data, ';', label)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0. 0. 0. 0. 0.] ; [0.]
[0. 0. 1. 0. 0.] ; [0.]
[0. 0. 0. 0. 1.] ; [0.]
[0. 1. 0. 0. 0.] ; [0.]
[0. 0. 0. 1. 0.] ; [0.]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;可迭代数据集&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可迭代的数据集是实现了&lt;code&gt;__iter__&lt;/code&gt;和&lt;code&gt;__next__&lt;/code&gt;方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。&lt;/p&gt;
&lt;p&gt;例如，当使用&lt;code&gt;iter(dataset)&lt;/code&gt;的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。&lt;/p&gt;
&lt;p&gt;下面构造一个简单迭代器，并将其加载至&lt;code&gt;GeneratorDataset&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 可迭代数据集
class IterableDataset():
    def __init__(self, start, end):
        '''初始化迭代器参数'''
        self.start = start
        self.end = end
    def __next__(self):
        '''获取下一迭代数据'''
        return next(self.data)
    def __iter__(self):
        '''创建迭代'''
        self.data = iter(range(self.start, self.end))
        return self
loader = IterableDataset(1, 5)
dataset = GeneratorDataset(source=loader, column_names=[&amp;quot;data&amp;quot;])
# in dataset 默认调用create_tuple_iterator()，会将Tensor数据封装进tuple
for d in dataset:
    print(d)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[Tensor(shape=[], dtype=Int64, value= 1)]
[Tensor(shape=[], dtype=Int64, value= 2)]
[Tensor(shape=[], dtype=Int64, value= 3)]
[Tensor(shape=[], dtype=Int64, value= 4)]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="3"&gt;
&lt;li&gt;生成器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型&lt;code&gt;generator&lt;/code&gt;返回数据，直至生成器抛出&lt;code&gt;StopIteration&lt;/code&gt;异常。&lt;/p&gt;
&lt;p&gt;下面构造一个生成器，并将其加载至&lt;code&gt;GeneratorDataset&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 生成器构造dataset
dataset = GeneratorDataset(source=iter(range(1,5)), column_names=[&amp;quot;data&amp;quot;])
for i in dataset:
    print(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[Tensor(shape=[], dtype=Int64, value= 1)]
[Tensor(shape=[], dtype=Int64, value= 2)]
[Tensor(shape=[], dtype=Int64, value= 3)]
[Tensor(shape=[], dtype=Int64, value= 4)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from datetime import datetime
import pytz
print(datetime.now(pytz.timezone('Asia/Shanghai')), '\nuser:YZSH-HSZY')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2024-07-04 23:39:18.933937+08:00 
user:YZSH-HSZY
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Mindspore"/></entry><entry><title>Mindspore Learen Notes -- Tensor Understand.</title><link href="https://yzsh-hszy.github.io/2024-07-02-mindspore-learen-notes-tensor-understand.html" rel="alternate"/><published>2024-07-02T12:00:00+08:00</published><updated>2024-07-02T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-02:/2024-07-02-mindspore-learen-notes-tensor-understand.html</id><summary type="html">&lt;h2&gt;张量介绍&lt;/h2&gt;
&lt;p&gt;张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;张量介绍&lt;/h2&gt;
&lt;p&gt;张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 𝑛 维空间内，有 $n^r$ 个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。 𝑟 称为该张量的秩或阶（与矩阵的秩和阶均无关系）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 张量是一种特殊的数据结构，与数组和矩阵非常相似。张量（Tensor）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。&lt;/p&gt;
&lt;h2&gt;张量与矩阵与数组与向量的区别&lt;/h2&gt;
&lt;p&gt;在numpy中，数据的结构有数组、矩阵、向量这几种描述方式，而在深度学习中通常使用张量来描述所有数据和相应的变换关系。在参与运算时他们之间的差距通常非常小，但却是不同角度下的描述，因此正确的理解并区分他们是必要的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# mindspore base moudel import
import numpy as np
import mindspore
from mindspore import ops
from mindspore import Tensor, CSRTensor, COOTensor
print('moudel import success')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;moudel import success
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;a base tensor create&lt;/h3&gt;
&lt;p&gt;构造张量时，支持传入Tensor、float、int、bool、tuple、list、complex和numpy.ndarray类型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据数据直接生成
可以根据数据创建张量，数据类型可以设置或者通过框架自动推断。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# python原生类型
int_tensor = Tensor(1)
float_tensor = Tensor(1.)
bool_tensor = Tensor(True)
tuple_tensor = Tensor((1,2))
list_tensor = Tensor([1,3])
complex_tensor = Tensor(complex(1,9))
temp_dict = locals()
for k,v in temp_dict.items():
    if k.endswith('tensor') and isinstance(v, Tensor):
        print(
            k, 
            ';value is :', v,
            ';shape is :', v.shape,
            ';dtype is :', v.dtype
        )
# Tensor、numpy.ndarray类型
nd_tensor = Tensor(np.array([[1,2],[3,4]], dtype=np.float32))
print('nd_tensor', id(nd_tensor), nd_tensor.shape, nd_tensor.dtype)
cp_tensor = Tensor(nd_tensor)
print('cp_tensor', id(cp_tensor), cp_tensor.shape, cp_tensor.dtype)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;int_tensor ;value is : 1 ;shape is : () ;dtype is : Int64
float_tensor ;value is : 1.0 ;shape is : () ;dtype is : Float32
bool_tensor ;value is : True ;shape is : () ;dtype is : Bool
tuple_tensor ;value is : [1 2] ;shape is : (2,) ;dtype is : Int64
list_tensor ;value is : [1 3] ;shape is : (2,) ;dtype is : Int64
complex_tensor ;value is : (1+9j) ;shape is : () ;dtype is : Complex128
nd_tensor 281468910652768 (2, 2) Float32
cp_tensor 281468910653168 (2, 2) Float32
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;使用init初始化器构造张量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当使用init初始化器对张量进行初始化时，支持传入的参数有init、shape、dtype。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;init: 支持传入initializer的子类。如：下方示例中的 One() 和 Normal()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shape: 支持传入 list、tuple、 int。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dtype: 支持传入mindspore.dtype。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from mindspore.common.initializer import One, Normal

# Initialize a tensor with ones
tensor1 = mindspore.Tensor(shape=(2, 2), dtype=mindspore.float32, init=One())
print(&amp;quot;tensor1:\n&amp;quot;, tensor1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;tensor1:
 [[1. 1.]
 [1. 1.]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Normal初始化器会将数据进行正太分布处理，公式如下:
$f(x) =  \frac{1} {\sqrt{2&lt;em&gt;π} * sigma}exp(-\frac{(x - mean)^2} {2&lt;/em&gt;{sigma}^2})$
参数默认值 sigma=0.01, mean=0.0，生成的x元素为随机值&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# Initialize a tensor from normal distribution
tensor2 = mindspore.Tensor(shape=(2, 3), dtype=mindspore.float32, init=Normal())
print(&amp;quot;tensor2:\n&amp;quot;, tensor2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;tensor2:
 [[ 0.01408593  0.00398565  0.01824992]
 [-0.00208053  0.01520424  0.01576259]]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在我探究Normal()作用时，注意到另一个和 &lt;code&gt;mindspore.Tensor&lt;/code&gt; 类似的类 &lt;code&gt;mindspore._c_expression.Tensor&lt;/code&gt;,那么他们有什么区别呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;为了解决这个问题，我编写了以下python代码验证：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from mindspore._c_expression import Tensor as Tensor_
import mindspore._c_expression as _c
# 这个_c_expression是一个so库文件，可以通过__file__属性查看其所在位置
print('the _c_expression so library file path is :', _c.__file__)
some_list = []  # 记载Tensor_和Tensor自身属性地址相同部分
diff_list = []
for k in dir(Tensor_):
    if k.startswith('__'): continue
    if id(getattr(Tensor_, k)) == id(getattr(Tensor,k)):
        some_list.append(k)
    else:
        diff_list.append(k)
print('-' * 20)
print('mindspore.Tensor and mindspore._c_expression.Tensor has some attrs is :',
      ' '.join(some_list))
print('all some attrs nums is :', len(some_list))
print('-' * 20)
print('mindspore.Tensor and mindspore._c_expression.Tensor has diff attrs is :',
       ' '.join(diff_list))
print('all diff attrs nums is :', len(diff_list))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;the _c_expression so library file path is : /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages/mindspore/_c_expression.cpython-39-aarch64-linux-gnu.so
--------------------
mindspore.Tensor and mindspore._c_expression.Tensor has some attrs is : _dtype _flatten_tensors _flush_from_cache _get_flattened_tensors _get_fusion_size _is_flattened _is_test_stub _itemsize _nbytes _shape _size _strides adapter_flag assign_value_cpp data_sync dim getitem_index_info init_flag is_init offload offload_file_path param_info persistent_data_from_numpy set_cast_dtype set_dtype set_init_flag setitem_index_info
all some attrs nums is : 27
--------------------
mindspore.Tensor and mindspore._c_expression.Tensor has diff attrs is : _offload asnumpy asnumpy_of_slice_persistent_data contiguous dtype from_numpy get_bytes is_contiguous is_persistent_data shape
all diff attrs nums is : 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到Tensor_和Tensor大部分属性的均指向同一地址，因为_c_expression是一个库扩展模块，要想更加详细的了解他们之间区别，需要去查看对应的c++源码实现。
这里只列出部分我探究的内容，更详细的解析请自行查看源码。&lt;/p&gt;
&lt;!-- TODO 未完成，仅列出部分以记录 --&gt;
&lt;ol&gt;
&lt;li&gt;python类Tensor的init方法在&lt;code&gt;mindspore\python\mindspore\common\tensor.py&lt;/code&gt;;在其初始化方法中最终均会调用&lt;code&gt;Tensor_.__init__&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;mindspore编写python扩展&lt;code&gt;_c_expression&lt;/code&gt;是通过&lt;code&gt;pybind11&lt;/code&gt;进行的，在&lt;code&gt;mindspore\ccsrc\CMakeLists.txt&lt;/code&gt;文件中存在调用&lt;code&gt;pybind11_add_module&lt;/code&gt;的cmake宏进行py模块绑定，对应文件为&lt;code&gt;mindspore\ccsrc\pipeline\jit\ps\init.cc&lt;/code&gt;，内有&lt;code&gt;PYBIND11_MODULE(_c_expression, m)&lt;/code&gt; 进行&lt;code&gt;_c_expression&lt;/code&gt;模块的具体代码绑定。&lt;/li&gt;
&lt;li&gt;第2步中，&lt;code&gt;_c_expression&lt;/code&gt;模块缺少py::class Tensor的绑定，我只在&lt;code&gt;mindspore\ccsrc\pybind_api\ir\tensor_py.cc&lt;/code&gt;中找到 &lt;code&gt;mindspore.Tensor&lt;/code&gt; 的绑定代码。&lt;/li&gt;
&lt;li&gt;进一步研究发现，&lt;code&gt;tensor_py.cc&lt;/code&gt;对应的&lt;code&gt;py::class Tensor&lt;/code&gt;绑定代码在函数&lt;code&gt;RegMetaTensor&lt;/code&gt;中，会被&lt;code&gt;RegModule&lt;/code&gt;调用，最终在&lt;code&gt;PYBIND11_MODULE&lt;/code&gt;中通过&lt;code&gt;mindspore::RegModuleHelper&lt;/code&gt;调用绑定，而&lt;code&gt;mindspore.Tensor&lt;/code&gt;继承自&lt;code&gt;_c_expression.Tensor&lt;/code&gt;类，可以通过类的mro方法查看继承关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(Tensor.mro())
print(Tensor_.mro())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;, &amp;lt;class 'mindspore._c_expression.Tensor'&amp;gt;, &amp;lt;class 'mindspore._c_expression.MetaTensor'&amp;gt;, &amp;lt;class 'pybind11_builtins.pybind11_object'&amp;gt;, &amp;lt;class 'object'&amp;gt;]
[&amp;lt;class 'mindspore._c_expression.Tensor'&amp;gt;, &amp;lt;class 'mindspore._c_expression.MetaTensor'&amp;gt;, &amp;lt;class 'pybind11_builtins.pybind11_object'&amp;gt;, &amp;lt;class 'object'&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 回到正题，张量Tensor的创建也可以根据另一个Tensor的属性进行
# mindspore提供了一个ops模块可用于Cell的构造
a_ones = ops.ones_like(tensor1)
a_zeros = ops.zeros_like(tensor1)
print('ops create ones tensor is:', a_ones)
print('ops create zeros tensor is:', a_zeros)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ops create ones tensor is: [[1. 1.]
 [1. 1.]]
ops create zeros tensor is: [[0. 0.]
 [0. 0.]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;张量的常用属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;形状（shape）：&lt;code&gt;Tensor&lt;/code&gt;的shape，是一个tuple。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据类型（dtype）：&lt;code&gt;Tensor&lt;/code&gt;元素的dtype，是MindSpore的一个数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单个元素大小（itemsize）： &lt;code&gt;Tensor&lt;/code&gt;中每一个元素占用字节数，是一个整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;占用字节数量（nbytes）： &lt;code&gt;Tensor&lt;/code&gt;占用的总字节数，是一个整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;维数（ndim）： &lt;code&gt;Tensor&lt;/code&gt;的秩，也就是len(tensor.shape)，是一个整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元素个数（size）： &lt;code&gt;Tensor&lt;/code&gt;中所有元素的个数，是一个整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一维步长（strides）： &lt;code&gt;Tensor&lt;/code&gt;每一维所需要的字节数，是一个tuple。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t = Tensor([[1,2,3],[1,7,9]])
print(&amp;quot;t_shape:&amp;quot;, t.shape)
print(&amp;quot;t_dtype:&amp;quot;, t.dtype)
print(&amp;quot;t_itemsize:&amp;quot;, t.itemsize)
print(&amp;quot;t_nbytes:&amp;quot;, t.nbytes)
print(&amp;quot;t_ndim:&amp;quot;, t.ndim)
print(&amp;quot;t_size:&amp;quot;, t.size)
print(&amp;quot;t_strides:&amp;quot;, t.strides)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;t_shape: (2, 3)
t_dtype: Int64
t_itemsize: 8
t_nbytes: 48
t_ndim: 2
t_size: 6
t_strides: (24, 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span display=hidden&gt;### 维度与维数区别
Tensorflow描述张量的维度：阶，形状以及维数&lt;/p&gt;
&lt;p&gt;TensorFlow用张量这种数据结构来表示所有的数据.你可以把一个张量想象成一个n维的数组或列表.一个张量有一个静态类型和动态类型的维数.张量可以在图中的节点之间流通。&lt;/p&gt;
&lt;p&gt;在TensorFlow系统中，张量的维数来被描述为阶。但是张量的阶和矩阵的阶并不是同一个概念。张量的阶（有时是关于如顺序或度数或者是n维）是张量维数的一个数量描述。&lt;/p&gt;
&lt;p&gt;比如，下面的张量（使用Python中list定义的）就是2阶。&lt;/p&gt;
&lt;p&gt;TensorFlow文档中使用了三种记号来方便地描述张量的维度：阶，形状以及维数.下表展示了他们之间的关系：
&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;张量索引&lt;/h3&gt;
&lt;p&gt;Tensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号:和 ...用于对数据进行切片。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print('the tensor is:', t)
print(&amp;quot;First row: {}&amp;quot;.format(t[0]))
print(&amp;quot;value of bottom right corner: {}&amp;quot;.format(t[1, 1]))
print(&amp;quot;Last column: {}&amp;quot;.format(t[:, -1]))
print(&amp;quot;First column: {}&amp;quot;.format(t[..., 0]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;the tensor is: [[1 2 3]
 [1 7 9]]
First row: [1 2 3]
value of bottom right corner: 7
Last column: [3 9]
First column: [1 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;张量运算&lt;/h3&gt;
&lt;p&gt;张量之间可以使用很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，使用方法和numpy类似&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;x = Tensor(np.array([9, 2, 3, 5]), mindspore.float32)
y = Tensor(np.array([4, 5, 6, 3]), mindspore.float32)
# 1. 算术运算
print(&amp;quot;add:&amp;quot;, x + y)
print(&amp;quot;sub:&amp;quot;, x - y)
print(&amp;quot;mul:&amp;quot;, x * y)
print(&amp;quot;div:&amp;quot;, x / y)
print(&amp;quot;mod:&amp;quot;, x % y)
print(&amp;quot;floordiv:&amp;quot;, x // y)
# 2. 矩阵处理
print(&amp;quot;转置:&amp;quot;, x.reshape((2,2)).T)
# 使用`ops.concat`连接张量
print(&amp;quot;concat tensors:&amp;quot;, ops.concat((x, y), axis=0))
# 使用ops.stack从新维度合并张量
print(&amp;quot;stack tensors:&amp;quot;, ops.stack([x,y]))
# 3. tensor与np.ndarray转换
print(f&amp;quot;x: {x}&amp;quot;, type(x))
n = x.asnumpy()
print(f&amp;quot;n: {n}&amp;quot;, type(n))

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;add: [13.  7.  9.  8.]
sub: [ 5. -3. -3.  2.]
mul: [36. 10. 18. 15.]
div: [2.25      0.4       0.5       1.6666666]
mod: [1. 2. 3. 2.]
floordiv: [2. 0. 0. 1.]
[[9. 3.]
 [2. 5.]]
concat tensors: [9. 2. 3. 5. 4. 5. 6. 3.]
stack tensors: [[9. 2. 3. 5.]
 [4. 5. 6. 3.]]
x: [9. 2. 3. 5.] &amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;
n: [9. 2. 3. 5.] &amp;lt;class 'numpy.ndarray'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;几种特殊tensor&lt;/h3&gt;
&lt;h4&gt;稀疏张量&lt;/h4&gt;
&lt;p&gt;稀疏张量中绝大部分元素的值为零。&lt;/p&gt;
&lt;p&gt;在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。&lt;/p&gt;
&lt;p&gt;MindSpore支持常用的&lt;code&gt;CSR&lt;/code&gt;和&lt;code&gt;COO&lt;/code&gt;两种稀疏数据格式，如&lt;code&gt;CSRTensor&lt;/code&gt;、&lt;code&gt;COOTensor&lt;/code&gt;和&lt;code&gt;RowTensor&lt;/code&gt;等&lt;/p&gt;
&lt;p&gt;常用稀疏张量的表达形式是&lt;code&gt;&amp;lt;indices:Tensor, values:Tensor, shape:Tensor&amp;gt;&lt;/code&gt;。其中，&lt;code&gt;indices&lt;/code&gt;表示非零下标元素， &lt;code&gt;values&lt;/code&gt;表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。&lt;/p&gt;
&lt;h5&gt;CSRTensor&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;CSR&lt;/code&gt;（Compressed Sparse Row，压缩稀疏行）稀疏张量格式有着高效的存储与计算的优势。其中，非零元素的值存储在&lt;code&gt;values&lt;/code&gt;中，非零元素的位置存储在&lt;code&gt;indptr&lt;/code&gt;（行）和&lt;code&gt;indices&lt;/code&gt;（列）中。各参数含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;indptr&lt;/code&gt;: 一维整数张量, 表示稀疏数据每一行的非零元素在&lt;code&gt;values&lt;/code&gt;中的起始位置和终止位置, 索引数据类型支持int16、int32、int64。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;indices&lt;/code&gt;: 一维整数张量，表示稀疏张量非零元素在列中的位置, 与&lt;code&gt;values&lt;/code&gt;长度相等，索引数据类型支持int16、int32、int64。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;values&lt;/code&gt;: 一维张量，表示&lt;code&gt;CSRTensor&lt;/code&gt;相对应的非零元素的值，与&lt;code&gt;indices&lt;/code&gt;长度相等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shape&lt;/code&gt;: 表示被压缩的稀疏张量的形状，数据类型为&lt;code&gt;Tuple&lt;/code&gt;，目前仅支持二维&lt;code&gt;CSRTensor&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; CSRTensor有以下限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CSR仅能表示二维张量&lt;/li&gt;
&lt;li&gt;行张量&lt;code&gt;indptr&lt;/code&gt;的&lt;code&gt;size&lt;/code&gt;为&lt;code&gt;csrtensor.shape[0]+1&lt;/code&gt;，其索引i表示csr张量第i行，值为列张量&lt;code&gt;indices&lt;/code&gt;索引，即指向该行第一个非0元素列位置&lt;/li&gt;
&lt;li&gt;列张量&lt;code&gt;indices&lt;/code&gt;，存储每个非0元素的列位置，长度与值张量&lt;code&gt;values&lt;/code&gt;相等，&lt;code&gt;indices[i]&lt;/code&gt; 表示第i个非0元素所在列位置&lt;/li&gt;
&lt;li&gt;值张量&lt;code&gt;values&lt;/code&gt; 存储csr所有非0值，按先行后列排序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 在Ascend平台，CSRTensor很多运算不可用&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;indptr = Tensor([0, 2, 4], dtype=mindspore.int32)
indices = Tensor([0, 2, 1, 3], dtype=mindspore.int32)
values = Tensor([1, 5, 2, 9], dtype=mindspore.float32)
shape = (2, 4)

# Make a CSRTensor
csr_tensor = CSRTensor(indptr, indices, values, shape)

print(csr_tensor.astype(mindspore.float64).dtype)
print(csr_tensor)
# 第一行元素indptr[0]首个非零元素在indices[indptr[0]]列出现，值为values[indptr[0]]
# 第二行元素indptr[1]首个非零元素在indices[indptr[1]]列出现，值为values[indptr[1]]
# values[indptr[0],indptr[1]]为第一行所有非零元素，列位置在indices中
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Float64
CSRTensor(shape=[2, 4], dtype=Float32, indptr=Tensor(shape=[3], dtype=Int32, value=[0 1 2]), indices=Tensor(shape=[4], dtype=Int32, value=[0 2 1 3]), values=Tensor(shape=[4], dtype=Float32, value=[ 1.00000000e+00  5.00000000e+00  2.00000000e+00  9.00000000e+00]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码表示如下所示的&lt;code&gt;CSRTensor&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;$$
\left[
\begin{matrix}
1 &amp;amp; 0 &amp;amp; 5 &amp;amp; 0 \
0 &amp;amp; 2 &amp;amp; 0 &amp;amp; 9
\end{matrix}
\right]
$$&lt;/p&gt;
&lt;h5&gt;COOTensor&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;COO&lt;/code&gt;（Coordinate Format）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为&lt;code&gt;N&lt;/code&gt;，被压缩的张量的维数为&lt;code&gt;ndims&lt;/code&gt;。各参数含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;indices&lt;/code&gt;: 二维整数张量，每行代表非零元素下标。形状：&lt;code&gt;[N, ndims]&lt;/code&gt;， 索引数据类型支持int16、int32、int64。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;values&lt;/code&gt;: 一维张量，表示相对应的非零元素的值。形状：&lt;code&gt;[N]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shape&lt;/code&gt;: 表示被压缩的稀疏张量的形状，目前仅支持二维&lt;code&gt;COOTensor&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; values中每个非零元素values[i]在COOTensor中的坐标为indices[i]，因此可支持多维Tensor&lt;/p&gt;
&lt;p&gt;下面给出一些COOTensor的使用示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;indices = Tensor([[0, 1], [1, 2]], dtype=mindspore.int32)
values = Tensor([1, 2], dtype=mindspore.float32)
shape = (3, 4)

# Make a COOTensor
COOTensor(indices, values, shape)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;COOTensor(shape=[3, 4], dtype=Float32, indices=Tensor(shape=[2, 2], dtype=Int32, value=
[[0 1]
 [1 2]]), values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码表示如下所示的&lt;code&gt;COOTensor&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;$$
\left[
\begin{matrix}
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \
0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 \
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0
\end{matrix}
\right]
$$&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from datetime import datetime
import pytz
print(datetime.now(pytz.timezone('Asia/Shanghai')), '\nuser:YZSH-HSZY')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2024-07-04 16:08:16.273507+08:00 
user:YZSH-HSZY
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Mindspore"/></entry><entry><title>MindSpore Learen Notes -- QuikStart.</title><link href="https://yzsh-hszy.github.io/2024-07-01-mindspore-learen-notes-quikstart.html" rel="alternate"/><published>2024-07-01T12:00:00+08:00</published><updated>2024-07-01T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-01:/2024-07-01-mindspore-learen-notes-quikstart.html</id><summary type="html">&lt;h1&gt;mindspore介绍&lt;/h1&gt;
&lt;p&gt;昇思MindSpore是一个全场景深度学习框架，旨在实现易开发、高效执行、全场景统一部署三大目标。
昇思提供一系列配套设施能够为简化深度学习过程，并提 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;mindspore介绍&lt;/h1&gt;
&lt;p&gt;昇思MindSpore是一个全场景深度学习框架，旨在实现易开发、高效执行、全场景统一部署三大目标。
昇思提供一系列配套设施能够为简化深度学习过程，并提供一些工具用于辅助开发AI项目。&lt;/p&gt;
&lt;h2&gt;mindspore名词解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shuffle(清洗)
数据集随机shuffle可以消除数据排列造成的分布不均问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map(映射，一般用于变换)
map操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;batch(批大小,统一批操作时数据保持相同形状)
将数据集打包为固定大小的batch是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;设置batch后，在随后的数据集每一次迭代获取数据时，返回一个batch大小的批数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;自定义数据集
mindspore.dataset 模块提供了一些常用的公开数据集(公开数据集请使用download下载，dataset只能加载本地数据集)和标准格式数据集的加载API。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过GeneratorDataset接口实现自定义方式的数据集加载。&lt;/p&gt;
&lt;p&gt;GeneratorDataset支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可随机访问数据集
可随机访问数据集是实现了__getitem__和__len__方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可迭代数据集
可迭代的数据集是实现了__iter__和__next__方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成器
生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型generator返回数据，直至生成器抛出StopIteration异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RGB图像格式
rgb图像是常见的彩色图像格式，但他在计算机内存中的存储顺序通常是按照BGR的顺序排列的。因为在Windows平台上，像素数据是按照BGR的顺序存储在内存中的。因此，当OpenCV之类的图像库读取一张RGB图像时，它会将像素数据按照BGR的顺序排列在内存中，而不是RGB的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HWC格式
HWC格式是指按照高度、宽度和通道数的顺序排列图像尺寸的格式。例如，一张形状为256×256×3的RGB图像，在HWC格式中表示为[256, 256, 3]。在一些图像处理库或者底层框架中，例如OpenCV和TensorFlow，通常使用HWC格式表示图像尺寸。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CHW格式
CHW格式是指按照通道数、高度和宽度的顺序排列图像尺寸的格式。在计算机视觉和深度学习中，通常使用CHW格式表示图像尺寸。如PyTorch等，因此转换CHW格式和HWC格式是有必要的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;实战&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import mindspore
from mindspore import nn
from mindspore.dataset import vision, transforms
from mindspore.dataset import MnistDataset
print('mindspore base moudle import')

# mindspore.dataset 模块提供api来加载和处理各种常用数据集，如MNIST、CIFAR-10, CIFAR-100, VOC, COCO, ImageNet, CelebA, CLUE等
# 它还支持数据集包括 MindRecord、TFRecord、Manifest等。用户还可以定义他们自己的数据集在这个模块。此外，该模块还提供了在加载时采样数据的api。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mindspore base moudle import
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# MNIST_Data数据集下载
# mnist数据集是由美国国家标准与技术研究所提供的手写数字图片数据集
from download import download

url = &amp;quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&amp;quot; \
      &amp;quot;notebook/datasets/MNIST_Data.zip&amp;quot;
path = download(url, &amp;quot;./&amp;quot;, kind=&amp;quot;zip&amp;quot;, replace=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Downloading data from https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/MNIST_Data.zip (10.3 MB)

file_sizes: 100%|███████████████████████████| 10.8M/10.8M [00:00&amp;lt;00:00, 136MB/s]
Extracting zip file...
Successfully downloaded / unzipped to ./
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(MnistDataset.__doc__)
# mnist数据集包含以下内容
# mnist_dataset_dir
 # ├── t10k-images-idx3-ubyte (10000个测试图片)
 # ├── t10k-labels-idx1-ubyte (10000个测试标签)
 # ├── train-images-idx3-ubyte (60000个训练图片)
 # └── train-labels-idx1-ubyte (60000个训练标签)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    MNIST dataset.

    The generated dataset has two columns :py:obj:`[image, label]` .
    The tensor of column :py:obj:`image` is of the uint8 type.
    The tensor of column :py:obj:`label` is a scalar of the uint32 type.

    Args:
        dataset_dir (str): Path to the root directory that contains the dataset.
        usage (str, optional): Usage of this dataset, can be ``'train'`` , ``'test'`` or ``'all'`` .
            ``'train'`` will read from 60,000 train samples, ``'test'`` will read from 10,000 test samples,
            ``'all'`` will read from all 70,000 samples. Default: ``None`` , will read all samples.
        num_samples (int, optional): The number of images to be included in the dataset.
            Default: ``None`` , will read all images.
        num_parallel_workers (int, optional): Number of worker threads to read the data.
            Default: ``None`` , will use global default workers(8), it can be set
            by :func:`mindspore.dataset.config.set_num_parallel_workers` .
        shuffle (bool, optional): Whether or not to perform shuffle on the dataset.
            Default: ``None`` , expected order behavior shown in the table below.
        sampler (Sampler, optional): Object used to choose samples from the
            dataset. Default: ``None`` , expected order behavior shown in the table below.
        num_shards (int, optional): Number of shards that the dataset will be divided into. Default: ``None`` .
            When this argument is specified, `num_samples` reflects the maximum sample number of per shard.
        shard_id (int, optional): The shard ID within `num_shards` . Default: ``None`` . This
            argument can only be specified when `num_shards` is also specified.
        cache (DatasetCache, optional): Use tensor caching service to speed up dataset processing. More details:
            `Single-Node Data Cache &amp;lt;https://www.mindspore.cn/tutorials/experts/en/r2.2/dataset/cache.html&amp;gt;`_ .
            Default: ``None`` , which means no cache is used.

    Raises:
        RuntimeError: If `dataset_dir` does not contain data files.
        ValueError: If `num_parallel_workers` exceeds the max thread numbers.
        ValueError: If `usage` is not ``'train'``、``'test'`` or ``'all'``.
        RuntimeError: If `sampler` and `shuffle` are specified at the same time.
        RuntimeError: If `sampler` and `num_shards`/`shard_id` are specified at the same time.
        RuntimeError: If `num_shards` is specified but shard_id is None.
        RuntimeError: If `shard_id` is specified but `num_shards` is None.
        ValueError: If `shard_id` is not in range of [0, `num_shards` ).

    Tutorial Examples:
        - `Load &amp;amp; Process Data With Dataset Pipeline
          &amp;lt;https://www.mindspore.cn/docs/en/r2.2/api_python/samples/dataset/dataset_gallery.html&amp;gt;`_

    Note:
        - The parameters `num_samples` , `shuffle` , `num_shards` , `shard_id` can be used to control the sampler
          used in the dataset, and their effects when combined with parameter `sampler` are as follows.

    .. include:: mindspore.dataset.sampler.txt

    Examples:
        &amp;gt;&amp;gt;&amp;gt; import mindspore.dataset as ds
        &amp;gt;&amp;gt;&amp;gt; mnist_dataset_dir = &amp;quot;/path/to/mnist_dataset_directory&amp;quot;
        &amp;gt;&amp;gt;&amp;gt;
        &amp;gt;&amp;gt;&amp;gt; # Read 3 samples from MNIST dataset
        &amp;gt;&amp;gt;&amp;gt; dataset = ds.MnistDataset(dataset_dir=mnist_dataset_dir, num_samples=3)
        &amp;gt;&amp;gt;&amp;gt;
        &amp;gt;&amp;gt;&amp;gt; # Note: In mnist_dataset dataset, each dictionary has keys &amp;quot;image&amp;quot; and &amp;quot;label&amp;quot;

    About MNIST dataset:

    The MNIST database of handwritten digits has a training set of 60,000 examples,
    and a test set of 10,000 examples. It is a subset of a larger set available from
    NIST. The digits have been size-normalized and centered in a fixed-size image.

    Here is the original MNIST dataset structure.
    You can unzip the dataset files into this directory structure and read by MindSpore's API.

    .. code-block::

        .
        └── mnist_dataset_dir
             ├── t10k-images-idx3-ubyte
             ├── t10k-labels-idx1-ubyte
             ├── train-images-idx3-ubyte
             └── train-labels-idx1-ubyte

    Citation:

    .. code-block::

        @article{lecun2010mnist,
        title        = {MNIST handwritten digit database},
        author       = {LeCun, Yann and Cortes, Corinna and Burges, CJ},
        journal      = {ATT Labs [Online]},
        volume       = {2},
        year         = {2010},
        howpublished = {http://yann.lecun.com/exdb/mnist}
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 查看MNIST_Data数据集内容

import numpy as np
import matplotlib.pyplot as plt
# 加载数据集，包含图像和标签两部分
train_dataset = MnistDataset(&amp;quot;MNIST_Data/train&amp;quot;, shuffle=False)
print('dataset:', type(train_dataset))
print('dataset`s cloumns is: ', train_dataset.get_col_names())

def visualize(dataset):
    &amp;quot;&amp;quot;&amp;quot;
    查看数据集中部分内容，这里是图片
    Args:
        dataset (_type_): 数据集
    &amp;quot;&amp;quot;&amp;quot;
    figure = plt.figure(figsize=(4, 4))
    cols, rows = 3, 3

    plt.subplots_adjust(wspace=0.5, hspace=0.5)

    for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):
        figure.add_subplot(rows, cols, idx + 1)
        plt.title(int(label))
        plt.axis(&amp;quot;off&amp;quot;)
        plt.imshow(image.asnumpy().squeeze(), cmap=&amp;quot;gray&amp;quot;)
        if idx == cols * rows - 1:
            break
    plt.show()
visualize(train_dataset)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;dataset: &amp;lt;class 'mindspore.dataset.engine.datasets_vision.MnistDataset'&amp;gt;
dataset`s cloumns is:  ['image', 'label']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/blog-doc_quikStarting_files/blog-doc_quikStarting_5_1.png" alt="png" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;img, label = next(train_dataset.create_tuple_iterator())
print('the img chw is : ', img.shape) # mnist数据中每张图像是一个25*25的灰度图
print('the label is : ', label)

def datapipe(dataset: MnistDataset, batch_size: int):
    image_transforms = [
        vision.Rescale(1.0 / 255.0, 0), # 将图像进行缩放处理
        vision.Normalize(mean=(0.1307,), std=(0.3081,)), # 将图像进行归一化处理
        vision.HWC2CHW() 
    ]
    label_transform = transforms.TypeCast(mindspore.int32)
    
    dataset = dataset.map(image_transforms, input_columns='image')
    dataset = dataset.map(label_transform, input_columns='label')
    dataset = dataset.batch(batch_size)
    return dataset
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;the img chw is :  (28, 28, 1)
the label is :  5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 数据处理
test_dataset = MnistDataset('MNIST_Data/test')

train_dataset = datapipe(train_dataset, 64)
test_dataset = datapipe(test_dataset, 64)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mindspore.dataset.engine.datasets_vision.MnistDataset
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;网络构建&lt;/h3&gt;
&lt;p&gt;神经网络模型是由神经网络层和Tensor操作构成的，mindspore.nn 提供了常见神经网络层的实现，在MindSpore中，Cell类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个Cell，它由不同的子Cell构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义模型类
当我们定义神经网络时，可以继承 nn.Cell 类，在__init__方法中进行子Cell的实例化和状态管理，在construct(构造)方法中实现Tensor操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;construct意为神经网络（或计算图）构建，相关内容详见使用静态图加速。construct()方法不可直接调用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Net(nn.Cell):
    def __init__(self):
        super().__init__()
        self.flatten = nn.Flatten()
        self.dense_relu_sequential = nn.SequentialCell(
            nn.Dense(28*28, 512),
            nn.ReLU(),
            nn.Dense(512, 512),
            nn.ReLU(),
            nn.Dense(512, 10)
        )
        
    def construct(self, x):
        x = self.flatten(x)
        logits = self.dense_relu_sequential(x)
        return logits
model = Net()
# 查看神经网络结构
print(model)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Net&amp;lt;
  (flatten): Flatten&amp;lt;&amp;gt;
  (dense_relu_sequential): SequentialCell&amp;lt;
    (0): Dense&amp;lt;input_channels=784, output_channels=512, has_bias=True&amp;gt;
    (1): ReLU&amp;lt;&amp;gt;
    (2): Dense&amp;lt;input_channels=512, output_channels=512, has_bias=True&amp;gt;
    (3): ReLU&amp;lt;&amp;gt;
    (4): Dense&amp;lt;input_channels=512, output_channels=10, has_bias=True&amp;gt;
    &amp;gt;
  &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from datetime import datetime
import pytz
print(datetime.now(pytz.timezone('Asia/Shanghai')))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2024-06-28 21:12:18.029531+08:00
&lt;/code&gt;&lt;/pre&gt;
</content><category term="MindSpore"/></entry></feed>