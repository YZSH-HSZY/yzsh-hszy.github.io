<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Welcome to YZSH-HSZY blog. - Mindspore</title><link href="https://yzsh-hszy.github.io/" rel="alternate"/><link href="https://yzsh-hszy.github.io/feeds/mindspore.atom.xml" rel="self"/><id>https://yzsh-hszy.github.io/</id><updated>2024-07-04T12:00:00+08:00</updated><entry><title>Mindspore Learen Notes -- Data Transfroms Operation Learen.</title><link href="https://yzsh-hszy.github.io/2024-07-04-mindspore-learen-notes-data-transfroms-operation-learen.html" rel="alternate"/><published>2024-07-04T12:00:00+08:00</published><updated>2024-07-04T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-04:/2024-07-04-mindspore-learen-notes-data-transfroms-operation-learen.html</id><summary type="html">&lt;h1&gt;数据变换 Transforms&lt;/h1&gt;
&lt;p&gt;通常情况下，直接加载的原始数据并不能直接送入神经网络进行训练，我们需要对其进行数据预处理。MindSpore提供不同种类的数据变换（Transforms），配 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;数据变换 Transforms&lt;/h1&gt;
&lt;p&gt;通常情况下，直接加载的原始数据并不能直接送入神经网络进行训练，我们需要对其进行数据预处理。MindSpore提供不同种类的数据变换（Transforms），配合数据处理Pipeline来实现数据预处理。所有的Transforms均可通过&lt;code&gt;map&lt;/code&gt;方法传入，实现对指定数据列的处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset&lt;/code&gt;提供了面向图像、文本、音频等不同数据类型的Transforms，同时也支持使用Lambda函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np
from PIL import Image
from download import download
from mindspore.dataset import transforms, vision, text
from mindspore.dataset import GeneratorDataset, MnistDataset
print('base moudel import')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;base moudel import
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Common Transforms(常用变换)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset.transforms&lt;/code&gt;模块支持一系列通用Transforms。这里我们以&lt;code&gt;Compose&lt;/code&gt;为例，介绍其使用方式。&lt;/p&gt;
&lt;h3&gt;Compose(组合)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 接收一个序列，序列内存放各种数据增强操作，然后将这几个数据操作合并为单个数据操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 以MNIST数据集演示
# MNIST数据集下载
url = &amp;quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&amp;quot; \
      &amp;quot;notebook/datasets/MNIST_Data.zip&amp;quot;
path = download(url, &amp;quot;./&amp;quot;, kind=&amp;quot;zip&amp;quot;, replace=True)
train_dataset = MnistDataset('MNIST_Data/train')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Downloading data from https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/MNIST_Data.zip (10.3 MB)

file_sizes: 100%|██████████████████████████| 10.8M/10.8M [00:00&amp;lt;00:00, 58.3MB/s]
Extracting zip file...
Successfully downloaded / unzipped to ./
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 合并图像缩放和形状变换为一个操作
composed = transforms.Compose(
    [
        vision.Rescale(1.0 / 255.0, 0),
        vision.HWC2CHW()
    ]
)
# 原image的数据类型和shape
image, label = next(train_dataset.create_tuple_iterator())
print('before image shape and type is:', image.shape, image.dtype)
# 应用合并变换操作
train_dataset = train_dataset.map(composed, 'image')
image, label = next(train_dataset.create_tuple_iterator())
print('compose transforms image shape and type is:', image.shape, image.dtype)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;before image shape and type is: (28, 28, 1) UInt8
compose transforms image shape and type is: (1, 28, 28) Float32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上述输出中可以看到，image数据的shape、dtype均发生变化&lt;/p&gt;
&lt;h2&gt;Vision Transforms(视觉变换)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset.vision&lt;/code&gt; 模块提供一系列针对图像数据的Transforms。&lt;/p&gt;
&lt;h3&gt;Rescale(缩放)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Rescale&lt;/code&gt;变换用于调整图像像素值的大小，包括两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rescale：缩放因子。&lt;/li&gt;
&lt;li&gt;shift：平移因子。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图像的每个像素将根据这两个参数进行调整，输出的像素值为$output_{i} = input_{i} * rescale + shift$。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 这里我们先使用numpy随机生成一个像素值在[0, 255]的图像
random_np = np.random.randint(0, 255, (4, 4), np.uint8)
random_image = Image.fromarray(random_np)
print('src img data is:\n', random_np)

# 将其像素值进行缩放
rescale_image = vision.Rescale(rescale = 1.0 / 255.0, shift = 1)(random_image)
print('rescale img data is:\n', np.asarray(rescale_image))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;src img data is:
 [[205 201 102 194]
 [ 80 124 234 241]
 [ 27  62 151 131]
 [ 32 225  37 244]]
rescale img data is:
 [[1.8039216 1.7882353 1.4       1.7607844]
 [1.3137255 1.4862745 1.9176471 1.945098 ]
 [1.1058824 1.2431372 1.5921569 1.5137255]
 [1.1254902 1.882353  1.1450981 1.9568628]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Normalize(归一化)&lt;/h3&gt;
&lt;p&gt;变换用于对输入图像的归一化，包括三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mean：图像每个通道的均值，必须为一个序列，否则raise TypeError&lt;/li&gt;
&lt;li&gt;std：图像每个通道的标准差，必须为一个序列，否则raise TypeError&lt;/li&gt;
&lt;li&gt;is_hwc：bool值，表示输入图像是否为HWC格式， True 为HWC格式， False 为CHW格式。默认值： True。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图像的每个通道将根据&lt;code&gt;mean&lt;/code&gt;和&lt;code&gt;std&lt;/code&gt;进行调整，计算公式为$output_{c} = \frac{input_{c} - mean_{c}}{std_{c}}$，其中 $c$代表通道索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 以(0.2)作为序列，会自动卸包，而(0.2,)，[0.2]不会&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;normalize = vision.Normalize(mean=(0.1,), std=[0.3])
random_image = Image.fromarray(np.random.randint(0, 255, (2,3,4), np.uint8))  # hwc格式的rgba图像
normalized_image = normalize(random_image)
print(normalized_image)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[[[616.3333   186.33333  562.99994  699.6666  ]
  [802.99994  726.3333   123.        16.333332]
  [339.66666  582.99994    9.666667 406.3333  ]]

 [[ 29.666664 173.       739.6666   386.3333  ]
  [626.3333   109.666664 496.33328   46.333332]
  [652.99994  146.33333  809.6666   159.66667 ]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HWC2CHW&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HWC2CHW&lt;/code&gt;变换用于转换图像格式。在不同的硬件设备中可能会对(height, width, channel)或(channel, height, width)两种不同格式有针对性优化。MindSpore设置HWC为默认图像格式，在有CHW格式需求时，可使用该变换进行处理。&lt;/p&gt;
&lt;p&gt;图像进行转换，只转换shape。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;hwc_image = Image.fromarray(np.random.randint(0, 255, (2,3,4), np.uint8))  # hwc格式的rgba图像
chw_image = vision.HWC2CHW()(hwc_image)
print(np.array(hwc_image).shape, chw_image.shape)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(2, 3, 4) (4, 2, 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Text Transforms(文本变换)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset.text&lt;/code&gt;模块提供一系列针对文本数据的Transforms。与图像数据不同，文本数据需要有分词（Tokenize）、构建词表、Token转Index等操作。&lt;/p&gt;
&lt;p&gt;首先我们定义三段文本，作为待处理的数据，并使用&lt;code&gt;GeneratorDataset&lt;/code&gt;进行加载。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;texts = ['Welcome to Beijing']
test_dataset = GeneratorDataset(texts, 'text')
# 查看test_dataset中数据格式
text_tensor, = next(test_dataset.create_tuple_iterator())
print(text_tensor, type(text_tensor))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Welcome to Beijing &amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;PythonTokenizer(分词器)&lt;/h3&gt;
&lt;p&gt;分词（Tokenize）操作是文本数据的基础处理方法，MindSpore提供多种不同的Tokenizer。这里我们选择基础的&lt;code&gt;PythonTokenizer&lt;/code&gt;举例，它允许用户自由实现分词策略。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;test_dataset = test_dataset.map(text.PythonTokenizer(lambda v: v.split()))
print(next(test_dataset.create_tuple_iterator()))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[Tensor(shape=[3], dtype=String, value= ['Welcome', 'to', 'Beijing'])]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Lookup&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Lookup&lt;/code&gt;为词表映射变换，用来将Token转换为Index。在使用&lt;code&gt;Lookup&lt;/code&gt;前，需要构造词表，一般可以加载已有的词表，或使用&lt;code&gt;Vocab&lt;/code&gt;生成词表。这里我们选择使用&lt;code&gt;Vocab.from_dataset&lt;/code&gt;方法从数据集中生成词表。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;vocab = text.Vocab.from_dataset(test_dataset)
# 使用`vocab`方法查看词表
print(vocab.vocab())
# 生成词表后，即可通过Lookup操作进行词表映射变换，将Token转为Index
test_dataset = test_dataset.map(text.Lookup(vocab))
print(next(test_dataset.create_tuple_iterator()))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{'to': 2, 'Welcome': 1, 'Beijing': 0}
[Tensor(shape=[3], dtype=Int32, value= [1, 2, 0])]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Lambda Transforms&lt;/h2&gt;
&lt;p&gt;通过Lambda Transforms，用户对简单的变换操作可以自定义lambda函数实现，更灵活。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;test_dataset = GeneratorDataset([1, 2, 3], 'data', shuffle=False)
test_dataset = test_dataset.map(lambda x: x * 2)
print(list(test_dataset.create_tuple_iterator()))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[[Tensor(shape=[], dtype=Int64, value= 2)], [Tensor(shape=[], dtype=Int64, value= 4)], [Tensor(shape=[], dtype=Int64, value= 6)]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Audio Transforms(音频变换)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset.audio&lt;/code&gt;模块提供一系列针对音频数据的Transforms。&lt;a href="https://www.mindspore.cn/docs/zh-CN/r2.3.0/api_python/samples/dataset/audio_gallery.html"&gt;参audio文档&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 安装librosa库
import pip
pip.main(['install', 'librosa'])

import librosa
import numpy as np
import matplotlib.pyplot as plt
import scipy.io.wavfile as wavfile
from IPython.display import Audio
from download import download

import mindspore.dataset as ds
import mindspore.dataset.audio as audio
print('Audio环境准备')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;WARNING: pip is being invoked by an old script wrapper. This will fail in a future version of pip.
Please see https://github.com/pypa/pip/issues/5599 for advice on fixing the underlying issue.
To avoid this problem you can invoke Python with '-m pip' instead of running pip directly.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: librosa in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (0.10.2.post1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: audioread&amp;gt;=2.1.9 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (3.0.1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: numpy!=1.22.0,!=1.22.1,!=1.22.2,&amp;gt;=1.20.3 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.26.4)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: scipy&amp;gt;=1.2.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.13.1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: scikit-learn&amp;gt;=0.20.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.5.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: joblib&amp;gt;=0.14 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.4.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: decorator&amp;gt;=4.3.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (5.1.1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: numba&amp;gt;=0.51.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (0.60.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: soundfile&amp;gt;=0.12.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (0.12.1)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: pooch&amp;gt;=1.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.8.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: soxr&amp;gt;=0.3.2 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (0.3.7)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: typing-extensions&amp;gt;=4.1.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (4.11.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: lazy-loader&amp;gt;=0.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (0.4)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: msgpack&amp;gt;=1.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from librosa) (1.0.8)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: packaging in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from lazy-loader&amp;gt;=0.1-&amp;gt;librosa) (23.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: llvmlite&amp;lt;0.44,&amp;gt;=0.43.0dev0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from numba&amp;gt;=0.51.0-&amp;gt;librosa) (0.43.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: platformdirs&amp;gt;=2.5.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from pooch&amp;gt;=1.1-&amp;gt;librosa) (4.2.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: requests&amp;gt;=2.19.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from pooch&amp;gt;=1.1-&amp;gt;librosa) (2.32.3)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: threadpoolctl&amp;gt;=3.1.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from scikit-learn&amp;gt;=0.20.0-&amp;gt;librosa) (3.5.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: cffi&amp;gt;=1.0 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from soundfile&amp;gt;=0.12.1-&amp;gt;librosa) (1.16.0)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: pycparser in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from cffi&amp;gt;=1.0-&amp;gt;soundfile&amp;gt;=0.12.1-&amp;gt;librosa) (2.22)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: charset-normalizer&amp;lt;4,&amp;gt;=2 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from requests&amp;gt;=2.19.0-&amp;gt;pooch&amp;gt;=1.1-&amp;gt;librosa) (3.3.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: idna&amp;lt;4,&amp;gt;=2.5 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from requests&amp;gt;=2.19.0-&amp;gt;pooch&amp;gt;=1.1-&amp;gt;librosa) (3.7)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: urllib3&amp;lt;3,&amp;gt;=1.21.1 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from requests&amp;gt;=2.19.0-&amp;gt;pooch&amp;gt;=1.1-&amp;gt;librosa) (2.2.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;Requirement already satisfied: certifi&amp;gt;=2017.4.17 in /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages (from requests&amp;gt;=2.19.0-&amp;gt;pooch&amp;gt;=1.1-&amp;gt;librosa) (2024.6.2)
&lt;/pre&gt;
&lt;pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace"&gt;
&lt;span style="font-weight: bold"&gt;[&lt;/span&gt;&lt;span style="color: #000080; text-decoration-color: #000080; background-color: #ffffff"&gt;notice&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff; font-weight: bold"&gt;]&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff"&gt; A new release of pip is available: &lt;/span&gt;&lt;span style="color: #800000; text-decoration-color: #800000; background-color: #ffffff"&gt;24.1&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff"&gt; -&amp;gt; &lt;/span&gt;&lt;span style="color: #008000; text-decoration-color: #008000; background-color: #ffffff"&gt;24.1.2&lt;/span&gt;
&lt;span style="font-weight: bold"&gt;[&lt;/span&gt;&lt;span style="color: #000080; text-decoration-color: #000080; background-color: #ffffff"&gt;notice&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff; font-weight: bold"&gt;]&lt;/span&gt;&lt;span style="color: #000000; text-decoration-color: #000000; background-color: #ffffff"&gt; To update, run: &lt;/span&gt;&lt;span style="color: #008000; text-decoration-color: #008000; background-color: #ffffff"&gt;python -m pip install --upgrade pip&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Audio环境准备
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 下载音频wav文件
url = &amp;quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/84-121123-0000.wav&amp;quot;
download(url, './84-121123-0000.wav', replace=True)
wav_file = &amp;quot;84-121123-0000.wav&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Downloading data from https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/84-121123-0000.wav (65 kB)

file_sizes: 100%|██████████████████████████| 67.0k/67.0k [00:00&amp;lt;00:00, 25.9MB/s]
Successfully downloaded file to ./84-121123-0000.wav
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Spectrogram&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Spectrogram&lt;/code&gt; 用于从音频信号创建其频谱&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 读取音频文件
sample_rate, waveform = wavfile.read(wav_file)

def plot_waveform(waveform, sr, title=&amp;quot;Waveform&amp;quot;):
    &amp;quot;&amp;quot;&amp;quot; 绘制音频波形图 &amp;quot;&amp;quot;&amp;quot;
    if waveform.ndim == 1:
        waveform = waveform[np.newaxis, :]
    num_channels, num_frames = waveform.shape
    time_axis = np.arange(0, num_frames) / sr

    figure, axes = plt.subplots(num_channels, 1)
    axes.plot(time_axis, waveform[0], linewidth=1)
    axes.grid(True)
    figure.suptitle(title)
    plt.show(block=False)
    
def plot_spectrogram(specgram, title=None, ylabel=&amp;quot;freq_bin&amp;quot;):
    &amp;quot;&amp;quot;&amp;quot; 绘制音频光谱图 &amp;quot;&amp;quot;&amp;quot;
    fig, axs = plt.subplots(1, 1)
    axs.set_title(title or &amp;quot;Spectrogram (db)&amp;quot;)
    axs.set_ylabel(ylabel)
    axs.set_xlabel(&amp;quot;frame&amp;quot;)
    im = axs.imshow(librosa.power_to_db(specgram), origin=&amp;quot;lower&amp;quot;, aspect=&amp;quot;auto&amp;quot;)
    fig.colorbar(im, ax=axs)
    plt.show(block=False)

plot_waveform(waveform, sample_rate, title=&amp;quot;Original waveform&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/fourth-blog_files/fourth-blog_25_0.png" alt="png" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 进行Spectrogram变换
n_fft = 1024
win_length = None
hop_length = 512

# Define transform
spectrogram = audio.Spectrogram(
    n_fft=n_fft,
    win_length=win_length,
    hop_length=hop_length,
    center=True,
    pad_mode=audio.BorderType.REFLECT,
    power=2.0,
)

spec = spectrogram(waveform)
plot_spectrogram(spec, title=&amp;quot;audio&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/fourth-blog_files/fourth-blog_26_0.png" alt="png" /&gt;&lt;/p&gt;
&lt;h3&gt;GriffinLim&lt;/h3&gt;
&lt;p&gt;从线性幅度频谱图恢复信号波形&lt;/p&gt;
&lt;h3&gt;Mel Filter Bank&lt;/h3&gt;
&lt;p&gt;mindspore.dataset.audio.melscale_fbanks 可以创建频率变换矩阵。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from datetime import datetime
import pytz
print(datetime.now(pytz.timezone('Asia/Shanghai')), '\nuser:YZSH-HSZY')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2024-07-19 18:33:26.985327+08:00 
user:YZSH-HSZY
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Mindspore"/></entry><entry><title>Mindspore Learen Notes -- Construct Dataset.</title><link href="https://yzsh-hszy.github.io/2024-07-03-mindspore-learen-notes-construct-dataset.html" rel="alternate"/><published>2024-07-03T12:00:00+08:00</published><updated>2024-07-03T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-03:/2024-07-03-mindspore-learen-notes-construct-dataset.html</id><summary type="html">&lt;h2&gt;数据集 Dataset&lt;/h2&gt;
&lt;p&gt;数据是深度学习的基础，高质量的数据输入将在整个深度神经网络中起到积极作用。MindSpore提供基于Pipeline的数据引擎，通过数据集（Dataset）和数据变 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;数据集 Dataset&lt;/h2&gt;
&lt;p&gt;数据是深度学习的基础，高质量的数据输入将在整个深度神经网络中起到积极作用。MindSpore提供基于Pipeline的数据引擎，通过数据集（Dataset）和数据变换（Transforms）实现高效的数据预处理。其中Dataset是Pipeline的起始，用于加载原始数据。mindspore.dataset提供了内置的文本、图像、音频等数据集加载接口，并提供了自定义数据集加载接口。&lt;/p&gt;
&lt;p&gt;此外MindSpore的领域开发库也提供了大量的预加载数据集，可以使用API一键下载使用。&lt;/p&gt;
&lt;h3&gt;名词介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据引擎：用于将数据集高效、灵活的转换至Tensor，并将该Tensor提供给训练网络用于训练，mindspore数据引擎是将在深度学习过程中数据输入到网络这一中间环境给抽取出来的一个中间件，支持python或c++插件，支持多端数据处理。&lt;/li&gt;
&lt;li&gt;Transforms数据变换：通常情况下，直接加载的原始数据并不能直接送入神经网络进行训练，我们需要对其进行数据预处理。MindSpore提供一个用于不同种类的数据进行变换的通用层mindspore.dataset.transforms，配合数据处理Pipeline来实现数据预处理。所有的Transforms均可通过map方法传入，实现对指定数据列的处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import numpy as np
import mindspore.dataset as ds
from mindspore.dataset import vision
from mindspore.dataset import MnistDataset, GeneratorDataset
import matplotlib.pyplot as plt
print('base moudle import')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;base moudle import
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据集加载&lt;/h3&gt;
&lt;p&gt;使用&lt;strong&gt;Mnist&lt;/strong&gt;数据集作为样例，介绍使用&lt;code&gt;mindspore.dataset&lt;/code&gt;进行加载的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; &lt;code&gt;mindspore.dataset&lt;/code&gt;提供的接口&lt;strong&gt;仅支持解压后的数据文件&lt;/strong&gt;，这里我们使用&lt;code&gt;download&lt;/code&gt;库下载数据集并解压。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# mnist数据集下载
from download import download

url = &amp;quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&amp;quot; \
      &amp;quot;notebook/datasets/MNIST_Data.zip&amp;quot;
path = download(url, &amp;quot;./&amp;quot;, kind=&amp;quot;zip&amp;quot;, replace=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Downloading data from https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/MNIST_Data.zip (10.3 MB)

file_sizes: 100%|███████████████████████████| 10.8M/10.8M [00:00&amp;lt;00:00, 154MB/s]
Extracting zip file...
Successfully downloaded / unzipped to ./
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 直接通过mindspore.dataset内置的MnistDataset类进行mnist数据加载
train_dataset = MnistDataset(&amp;quot;MNIST_Data/train&amp;quot;, shuffle=False)
print(type(train_dataset))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;class 'mindspore.dataset.engine.datasets_vision.MnistDataset'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数据集迭代&lt;/h3&gt;
&lt;p&gt;数据集加载后，一般以迭代方式获取数据，然后送入神经网络中进行训练。mindspore.dataset提供create_tuple_iterator和create_dict_iterator接口用于创建数据迭代器，迭代访问数据。&lt;/p&gt;
&lt;p&gt;访问的数据类型默认为&lt;code&gt;Tensor&lt;/code&gt;；若设置&lt;code&gt;output_numpy=True&lt;/code&gt;，访问的数据类型为&lt;code&gt;Numpy&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for idx, item in enumerate(train_dataset.create_tuple_iterator()):
    if idx == 1: break
    print(
        'the create_tuple_iterator generate`s iter length is :', len(item), 
        '\nthe iter item type is :', type(item),
        '\nelement in iter item type is :', [type(i) for i in item]
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;the create_tuple_iterator generate`s iter length is : 2 
the iter item type is : &amp;lt;class 'list'&amp;gt; 
element in iter item type is : [&amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;, &amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写可视化函数查看mnist手写数字识别数据集中图像数据&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def visualize(dataset):
    figure = plt.figure(figsize=(4, 4))
    cols, rows = 3, 3
    plt.subplots_adjust(wspace=0.5, hspace=0.5)
    for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):
        figure.add_subplot(rows, cols, idx + 1)
        plt.title(int(label))
        plt.axis(&amp;quot;off&amp;quot;)
        plt.imshow(image.asnumpy().squeeze(), cmap=&amp;quot;gray&amp;quot;)
        if idx == cols * rows - 1:
            break
    plt.show()
visualize(train_dataset)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/third-blog_files/third-blog_9_0.png" alt="png" /&gt;&lt;/p&gt;
&lt;h3&gt;数据集常用操作&lt;/h3&gt;
&lt;p&gt;Pipeline的设计理念使得数据集的常用操作采用&lt;code&gt;dataset = dataset.operation()&lt;/code&gt;的异步执行方式，执行操作返回新的Dataset，此时不执行具体操作，而是在Pipeline中加入节点，最终进行迭代时，并行执行整个Pipeline。&lt;/p&gt;
&lt;h4&gt;shuffle&lt;/h4&gt;
&lt;p&gt;数据集随机&lt;code&gt;shuffle&lt;/code&gt;可以消除数据排列造成的分布不均问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset&lt;/code&gt;提供的数据集在加载时可配置&lt;code&gt;shuffle=True&lt;/code&gt;，或直接对数据集使用&lt;code&gt;shuffle&lt;/code&gt;方法获取新随机数据集&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 参数buffer_size必须，为进行数据重排时每行大小
train_dataset = train_dataset.shuffle(buffer_size=4)
visualize(train_dataset)
# 从下图中可以看到数据顺序发生变化
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/third-blog_files/third-blog_12_0.png" alt="png" /&gt;&lt;/p&gt;
&lt;h4&gt;map&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 如何查看数据集列名，可以通过create_dict_iterator的dict.keys集合获取
print('train_dataset columns name is:', next(train_dataset.create_dict_iterator()).keys())
image, label = next(train_dataset.create_tuple_iterator())
print('img data shape and type is:', image.shape, image.dtype)
print('label data shape and type is:', label.shape, label.dtype)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;train_dataset columns name is: dict_keys(['image', 'label'])
img data shape and type is: (28, 28, 1) UInt8
label data shape and type is: () UInt32
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from itertools import product
train_dataset = MnistDataset(&amp;quot;MNIST_Data/train&amp;quot;, shuffle=False)  # 重新加载数据集
image, label = next(train_dataset.create_tuple_iterator())
print('a image shape is:', image.shape)
# 查看第一张图片所有非零值
the_first_no_zeros_sign = False
the_first_no_zeros_index = None
for i in product(*[range(s) for s in image.shape]):
    if image.item(i):
        if not the_first_no_zeros_sign: 
            print('the first no zeros index is:', i)
            the_first_no_zeros_index, the_first_no_zeros_sign = i, True
            print('first image all no zeros', end=':')
        print(image.item(i), end='-')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;a image shape is: (28, 28, 1)
the first no zeros index is: (5, 12, 0)
first image all no zeros:3-18-18-18-126-136-175-26-166-255-247-127-30-36-94-154-170-253-253-253-253-253-225-172-253-242-195-64-49-238-253-253-253-253-253-253-253-253-251-93-82-82-56-39-18-219-253-253-253-253-253-198-182-247-241-80-156-107-253-253-205-11-43-154-14-1-154-253-90-139-253-190-2-11-190-253-70-35-241-225-160-108-1-81-240-253-253-119-25-45-186-253-253-150-27-16-93-252-253-187-249-253-249-64-46-130-183-253-253-207-2-39-148-229-253-253-253-250-182-24-114-221-253-253-253-253-201-78-23-66-213-253-253-253-253-198-81-2-18-171-219-253-253-253-253-195-80-9-55-172-226-253-253-253-253-244-133-11-136-253-253-253-212-135-132-16-
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 通过vision的视觉操作进行image列处理
train_dataset = MnistDataset(&amp;quot;MNIST_Data/train&amp;quot;, shuffle=False)  # 重新加载数据集
train_dataset = train_dataset.map(vision.Rescale(1.0 / 255.0, 0), input_columns='image')
image, label = next(train_dataset.create_tuple_iterator())
print('map op then first image shape and type is:', image.shape, image.dtype)
print('the first no zeros index is:', the_first_no_zeros_index)
print('the uint8 to float32 value is:', image.item(the_first_no_zeros_index))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;map op then first image shape and type is: (28, 28, 1) Float32
the first no zeros index is: (5, 12, 0)
the uint8 to float32 value is: 0.011764707
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;batch&lt;/h4&gt;
&lt;p&gt;将数据集打包为固定大小的&lt;code&gt;batch&lt;/code&gt;是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。&lt;/p&gt;
&lt;p&gt;一般我们会设置一个固定的batch size，将连续的数据分为若干批（batch）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; &lt;code&gt;batch&lt;/code&gt;操作后的数据增加一维，大小为&lt;code&gt;batch_size&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;train_dataset = train_dataset.batch(batch_size=4)
image, label = next(train_dataset.create_tuple_iterator())
print(image.shape, image.dtype)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(4, 28, 28, 1) Float32
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;自定义数据集&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mindspore.dataset&lt;/code&gt;模块提供了一些常用的公开数据集和标准格式数据集的加载API。&lt;/p&gt;
&lt;p&gt;对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过&lt;code&gt;GeneratorDataset&lt;/code&gt;接口实现自定义方式的数据集加载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GeneratorDataset&lt;/code&gt;支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可随机访问数据集&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可随机访问数据集是实现了&lt;code&gt;__getitem__&lt;/code&gt;和&lt;code&gt;__len__&lt;/code&gt;方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。&lt;/p&gt;
&lt;p&gt;例如，当使用&lt;code&gt;dataset[idx]&lt;/code&gt;访问这样的数据集时，可以读取dataset内容中第idx个样本或标签，该条数据可以通过GeneratorDataset接口转换为Tensor类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 可随机访问数据集在生成迭代Tensor组时，是随机获取的&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 可随机访问数据集，包含5组数据
class RandomAccessDataset:
    def __init__(self):
        self._data = np.eye(5, k=1)
        self._label = np.zeros((5, 1))

    def __getitem__(self, index):
        return self._data[index], self._label[index]

    def __len__(self):
        return len(self._data)
# 自定义数据集转换为mindspore可操作的dataset
loader = RandomAccessDataset()
dataset = GeneratorDataset(source=loader, column_names=[&amp;quot;data&amp;quot;, &amp;quot;label&amp;quot;])
# 数据随机
for data, label in dataset.create_tuple_iterator():
    print(data, ';', label)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0. 0. 0. 0. 0.] ; [0.]
[0. 0. 1. 0. 0.] ; [0.]
[0. 0. 0. 0. 1.] ; [0.]
[0. 1. 0. 0. 0.] ; [0.]
[0. 0. 0. 1. 0.] ; [0.]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;可迭代数据集&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可迭代的数据集是实现了&lt;code&gt;__iter__&lt;/code&gt;和&lt;code&gt;__next__&lt;/code&gt;方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。&lt;/p&gt;
&lt;p&gt;例如，当使用&lt;code&gt;iter(dataset)&lt;/code&gt;的形式访问数据集时，可以读取从数据库、远程服务器返回的数据流。&lt;/p&gt;
&lt;p&gt;下面构造一个简单迭代器，并将其加载至&lt;code&gt;GeneratorDataset&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 可迭代数据集
class IterableDataset():
    def __init__(self, start, end):
        '''初始化迭代器参数'''
        self.start = start
        self.end = end
    def __next__(self):
        '''获取下一迭代数据'''
        return next(self.data)
    def __iter__(self):
        '''创建迭代'''
        self.data = iter(range(self.start, self.end))
        return self
loader = IterableDataset(1, 5)
dataset = GeneratorDataset(source=loader, column_names=[&amp;quot;data&amp;quot;])
# in dataset 默认调用create_tuple_iterator()，会将Tensor数据封装进tuple
for d in dataset:
    print(d)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[Tensor(shape=[], dtype=Int64, value= 1)]
[Tensor(shape=[], dtype=Int64, value= 2)]
[Tensor(shape=[], dtype=Int64, value= 3)]
[Tensor(shape=[], dtype=Int64, value= 4)]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="3"&gt;
&lt;li&gt;生成器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型&lt;code&gt;generator&lt;/code&gt;返回数据，直至生成器抛出&lt;code&gt;StopIteration&lt;/code&gt;异常。&lt;/p&gt;
&lt;p&gt;下面构造一个生成器，并将其加载至&lt;code&gt;GeneratorDataset&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 生成器构造dataset
dataset = GeneratorDataset(source=iter(range(1,5)), column_names=[&amp;quot;data&amp;quot;])
for i in dataset:
    print(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[Tensor(shape=[], dtype=Int64, value= 1)]
[Tensor(shape=[], dtype=Int64, value= 2)]
[Tensor(shape=[], dtype=Int64, value= 3)]
[Tensor(shape=[], dtype=Int64, value= 4)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from datetime import datetime
import pytz
print(datetime.now(pytz.timezone('Asia/Shanghai')), '\nuser:YZSH-HSZY')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2024-07-04 23:39:18.933937+08:00 
user:YZSH-HSZY
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Mindspore"/></entry><entry><title>Mindspore Learen Notes -- Tensor Understand.</title><link href="https://yzsh-hszy.github.io/2024-07-02-mindspore-learen-notes-tensor-understand.html" rel="alternate"/><published>2024-07-02T12:00:00+08:00</published><updated>2024-07-02T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-02:/2024-07-02-mindspore-learen-notes-tensor-understand.html</id><summary type="html">&lt;h2&gt;张量介绍&lt;/h2&gt;
&lt;p&gt;张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;张量介绍&lt;/h2&gt;
&lt;p&gt;张量（Tensor）是一个可用来表示在一些矢量、标量和其他张量之间的线性关系的多线性函数，这些线性关系的基本例子有内积、外积、线性映射以及笛卡儿积。其坐标在 𝑛 维空间内，有 $n^r$ 个分量的一种量，其中每个分量都是坐标的函数，而在坐标变换时，这些分量也依照某些规则作线性变换。 𝑟 称为该张量的秩或阶（与矩阵的秩和阶均无关系）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 张量是一种特殊的数据结构，与数组和矩阵非常相似。张量（Tensor）是MindSpore网络运算中的基本数据结构，本教程主要介绍张量和稀疏张量的属性及用法。&lt;/p&gt;
&lt;h2&gt;张量与矩阵与数组与向量的区别&lt;/h2&gt;
&lt;p&gt;在numpy中，数据的结构有数组、矩阵、向量这几种描述方式，而在深度学习中通常使用张量来描述所有数据和相应的变换关系。在参与运算时他们之间的差距通常非常小，但却是不同角度下的描述，因此正确的理解并区分他们是必要的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# mindspore base moudel import
import numpy as np
import mindspore
from mindspore import ops
from mindspore import Tensor, CSRTensor, COOTensor
print('moudel import success')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;moudel import success
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;a base tensor create&lt;/h3&gt;
&lt;p&gt;构造张量时，支持传入Tensor、float、int、bool、tuple、list、complex和numpy.ndarray类型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据数据直接生成
可以根据数据创建张量，数据类型可以设置或者通过框架自动推断。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# python原生类型
int_tensor = Tensor(1)
float_tensor = Tensor(1.)
bool_tensor = Tensor(True)
tuple_tensor = Tensor((1,2))
list_tensor = Tensor([1,3])
complex_tensor = Tensor(complex(1,9))
temp_dict = locals()
for k,v in temp_dict.items():
    if k.endswith('tensor') and isinstance(v, Tensor):
        print(
            k, 
            ';value is :', v,
            ';shape is :', v.shape,
            ';dtype is :', v.dtype
        )
# Tensor、numpy.ndarray类型
nd_tensor = Tensor(np.array([[1,2],[3,4]], dtype=np.float32))
print('nd_tensor', id(nd_tensor), nd_tensor.shape, nd_tensor.dtype)
cp_tensor = Tensor(nd_tensor)
print('cp_tensor', id(cp_tensor), cp_tensor.shape, cp_tensor.dtype)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;int_tensor ;value is : 1 ;shape is : () ;dtype is : Int64
float_tensor ;value is : 1.0 ;shape is : () ;dtype is : Float32
bool_tensor ;value is : True ;shape is : () ;dtype is : Bool
tuple_tensor ;value is : [1 2] ;shape is : (2,) ;dtype is : Int64
list_tensor ;value is : [1 3] ;shape is : (2,) ;dtype is : Int64
complex_tensor ;value is : (1+9j) ;shape is : () ;dtype is : Complex128
nd_tensor 281468910652768 (2, 2) Float32
cp_tensor 281468910653168 (2, 2) Float32
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;使用init初始化器构造张量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当使用init初始化器对张量进行初始化时，支持传入的参数有init、shape、dtype。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;init: 支持传入initializer的子类。如：下方示例中的 One() 和 Normal()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shape: 支持传入 list、tuple、 int。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dtype: 支持传入mindspore.dtype。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from mindspore.common.initializer import One, Normal

# Initialize a tensor with ones
tensor1 = mindspore.Tensor(shape=(2, 2), dtype=mindspore.float32, init=One())
print(&amp;quot;tensor1:\n&amp;quot;, tensor1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;tensor1:
 [[1. 1.]
 [1. 1.]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Normal初始化器会将数据进行正太分布处理，公式如下:
$f(x) =  \frac{1} {\sqrt{2&lt;em&gt;π} * sigma}exp(-\frac{(x - mean)^2} {2&lt;/em&gt;{sigma}^2})$
参数默认值 sigma=0.01, mean=0.0，生成的x元素为随机值&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# Initialize a tensor from normal distribution
tensor2 = mindspore.Tensor(shape=(2, 3), dtype=mindspore.float32, init=Normal())
print(&amp;quot;tensor2:\n&amp;quot;, tensor2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;tensor2:
 [[ 0.01408593  0.00398565  0.01824992]
 [-0.00208053  0.01520424  0.01576259]]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在我探究Normal()作用时，注意到另一个和 &lt;code&gt;mindspore.Tensor&lt;/code&gt; 类似的类 &lt;code&gt;mindspore._c_expression.Tensor&lt;/code&gt;,那么他们有什么区别呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;为了解决这个问题，我编写了以下python代码验证：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from mindspore._c_expression import Tensor as Tensor_
import mindspore._c_expression as _c
# 这个_c_expression是一个so库文件，可以通过__file__属性查看其所在位置
print('the _c_expression so library file path is :', _c.__file__)
some_list = []  # 记载Tensor_和Tensor自身属性地址相同部分
diff_list = []
for k in dir(Tensor_):
    if k.startswith('__'): continue
    if id(getattr(Tensor_, k)) == id(getattr(Tensor,k)):
        some_list.append(k)
    else:
        diff_list.append(k)
print('-' * 20)
print('mindspore.Tensor and mindspore._c_expression.Tensor has some attrs is :',
      ' '.join(some_list))
print('all some attrs nums is :', len(some_list))
print('-' * 20)
print('mindspore.Tensor and mindspore._c_expression.Tensor has diff attrs is :',
       ' '.join(diff_list))
print('all diff attrs nums is :', len(diff_list))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;the _c_expression so library file path is : /home/nginx/miniconda/envs/jupyter/lib/python3.9/site-packages/mindspore/_c_expression.cpython-39-aarch64-linux-gnu.so
--------------------
mindspore.Tensor and mindspore._c_expression.Tensor has some attrs is : _dtype _flatten_tensors _flush_from_cache _get_flattened_tensors _get_fusion_size _is_flattened _is_test_stub _itemsize _nbytes _shape _size _strides adapter_flag assign_value_cpp data_sync dim getitem_index_info init_flag is_init offload offload_file_path param_info persistent_data_from_numpy set_cast_dtype set_dtype set_init_flag setitem_index_info
all some attrs nums is : 27
--------------------
mindspore.Tensor and mindspore._c_expression.Tensor has diff attrs is : _offload asnumpy asnumpy_of_slice_persistent_data contiguous dtype from_numpy get_bytes is_contiguous is_persistent_data shape
all diff attrs nums is : 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到Tensor_和Tensor大部分属性的均指向同一地址，因为_c_expression是一个库扩展模块，要想更加详细的了解他们之间区别，需要去查看对应的c++源码实现。
这里只列出部分我探究的内容，更详细的解析请自行查看源码。&lt;/p&gt;
&lt;!-- TODO 未完成，仅列出部分以记录 --&gt;
&lt;ol&gt;
&lt;li&gt;python类Tensor的init方法在&lt;code&gt;mindspore\python\mindspore\common\tensor.py&lt;/code&gt;;在其初始化方法中最终均会调用&lt;code&gt;Tensor_.__init__&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;mindspore编写python扩展&lt;code&gt;_c_expression&lt;/code&gt;是通过&lt;code&gt;pybind11&lt;/code&gt;进行的，在&lt;code&gt;mindspore\ccsrc\CMakeLists.txt&lt;/code&gt;文件中存在调用&lt;code&gt;pybind11_add_module&lt;/code&gt;的cmake宏进行py模块绑定，对应文件为&lt;code&gt;mindspore\ccsrc\pipeline\jit\ps\init.cc&lt;/code&gt;，内有&lt;code&gt;PYBIND11_MODULE(_c_expression, m)&lt;/code&gt; 进行&lt;code&gt;_c_expression&lt;/code&gt;模块的具体代码绑定。&lt;/li&gt;
&lt;li&gt;第2步中，&lt;code&gt;_c_expression&lt;/code&gt;模块缺少py::class Tensor的绑定，我只在&lt;code&gt;mindspore\ccsrc\pybind_api\ir\tensor_py.cc&lt;/code&gt;中找到 &lt;code&gt;mindspore.Tensor&lt;/code&gt; 的绑定代码。&lt;/li&gt;
&lt;li&gt;进一步研究发现，&lt;code&gt;tensor_py.cc&lt;/code&gt;对应的&lt;code&gt;py::class Tensor&lt;/code&gt;绑定代码在函数&lt;code&gt;RegMetaTensor&lt;/code&gt;中，会被&lt;code&gt;RegModule&lt;/code&gt;调用，最终在&lt;code&gt;PYBIND11_MODULE&lt;/code&gt;中通过&lt;code&gt;mindspore::RegModuleHelper&lt;/code&gt;调用绑定，而&lt;code&gt;mindspore.Tensor&lt;/code&gt;继承自&lt;code&gt;_c_expression.Tensor&lt;/code&gt;类，可以通过类的mro方法查看继承关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(Tensor.mro())
print(Tensor_.mro())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;, &amp;lt;class 'mindspore._c_expression.Tensor'&amp;gt;, &amp;lt;class 'mindspore._c_expression.MetaTensor'&amp;gt;, &amp;lt;class 'pybind11_builtins.pybind11_object'&amp;gt;, &amp;lt;class 'object'&amp;gt;]
[&amp;lt;class 'mindspore._c_expression.Tensor'&amp;gt;, &amp;lt;class 'mindspore._c_expression.MetaTensor'&amp;gt;, &amp;lt;class 'pybind11_builtins.pybind11_object'&amp;gt;, &amp;lt;class 'object'&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 回到正题，张量Tensor的创建也可以根据另一个Tensor的属性进行
# mindspore提供了一个ops模块可用于Cell的构造
a_ones = ops.ones_like(tensor1)
a_zeros = ops.zeros_like(tensor1)
print('ops create ones tensor is:', a_ones)
print('ops create zeros tensor is:', a_zeros)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ops create ones tensor is: [[1. 1.]
 [1. 1.]]
ops create zeros tensor is: [[0. 0.]
 [0. 0.]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;张量的常用属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;形状（shape）：&lt;code&gt;Tensor&lt;/code&gt;的shape，是一个tuple。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据类型（dtype）：&lt;code&gt;Tensor&lt;/code&gt;元素的dtype，是MindSpore的一个数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单个元素大小（itemsize）： &lt;code&gt;Tensor&lt;/code&gt;中每一个元素占用字节数，是一个整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;占用字节数量（nbytes）： &lt;code&gt;Tensor&lt;/code&gt;占用的总字节数，是一个整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;维数（ndim）： &lt;code&gt;Tensor&lt;/code&gt;的秩，也就是len(tensor.shape)，是一个整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元素个数（size）： &lt;code&gt;Tensor&lt;/code&gt;中所有元素的个数，是一个整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一维步长（strides）： &lt;code&gt;Tensor&lt;/code&gt;每一维所需要的字节数，是一个tuple。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t = Tensor([[1,2,3],[1,7,9]])
print(&amp;quot;t_shape:&amp;quot;, t.shape)
print(&amp;quot;t_dtype:&amp;quot;, t.dtype)
print(&amp;quot;t_itemsize:&amp;quot;, t.itemsize)
print(&amp;quot;t_nbytes:&amp;quot;, t.nbytes)
print(&amp;quot;t_ndim:&amp;quot;, t.ndim)
print(&amp;quot;t_size:&amp;quot;, t.size)
print(&amp;quot;t_strides:&amp;quot;, t.strides)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;t_shape: (2, 3)
t_dtype: Int64
t_itemsize: 8
t_nbytes: 48
t_ndim: 2
t_size: 6
t_strides: (24, 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span display=hidden&gt;### 维度与维数区别
Tensorflow描述张量的维度：阶，形状以及维数&lt;/p&gt;
&lt;p&gt;TensorFlow用张量这种数据结构来表示所有的数据.你可以把一个张量想象成一个n维的数组或列表.一个张量有一个静态类型和动态类型的维数.张量可以在图中的节点之间流通。&lt;/p&gt;
&lt;p&gt;在TensorFlow系统中，张量的维数来被描述为阶。但是张量的阶和矩阵的阶并不是同一个概念。张量的阶（有时是关于如顺序或度数或者是n维）是张量维数的一个数量描述。&lt;/p&gt;
&lt;p&gt;比如，下面的张量（使用Python中list定义的）就是2阶。&lt;/p&gt;
&lt;p&gt;TensorFlow文档中使用了三种记号来方便地描述张量的维度：阶，形状以及维数.下表展示了他们之间的关系：
&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;张量索引&lt;/h3&gt;
&lt;p&gt;Tensor索引与Numpy索引类似，索引从0开始编制，负索引表示按倒序编制，冒号:和 ...用于对数据进行切片。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print('the tensor is:', t)
print(&amp;quot;First row: {}&amp;quot;.format(t[0]))
print(&amp;quot;value of bottom right corner: {}&amp;quot;.format(t[1, 1]))
print(&amp;quot;Last column: {}&amp;quot;.format(t[:, -1]))
print(&amp;quot;First column: {}&amp;quot;.format(t[..., 0]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;the tensor is: [[1 2 3]
 [1 7 9]]
First row: [1 2 3]
value of bottom right corner: 7
Last column: [3 9]
First column: [1 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;张量运算&lt;/h3&gt;
&lt;p&gt;张量之间可以使用很多运算，包括算术、线性代数、矩阵处理（转置、标引、切片）、采样等，使用方法和numpy类似&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;x = Tensor(np.array([9, 2, 3, 5]), mindspore.float32)
y = Tensor(np.array([4, 5, 6, 3]), mindspore.float32)
# 1. 算术运算
print(&amp;quot;add:&amp;quot;, x + y)
print(&amp;quot;sub:&amp;quot;, x - y)
print(&amp;quot;mul:&amp;quot;, x * y)
print(&amp;quot;div:&amp;quot;, x / y)
print(&amp;quot;mod:&amp;quot;, x % y)
print(&amp;quot;floordiv:&amp;quot;, x // y)
# 2. 矩阵处理
print(&amp;quot;转置:&amp;quot;, x.reshape((2,2)).T)
# 使用`ops.concat`连接张量
print(&amp;quot;concat tensors:&amp;quot;, ops.concat((x, y), axis=0))
# 使用ops.stack从新维度合并张量
print(&amp;quot;stack tensors:&amp;quot;, ops.stack([x,y]))
# 3. tensor与np.ndarray转换
print(f&amp;quot;x: {x}&amp;quot;, type(x))
n = x.asnumpy()
print(f&amp;quot;n: {n}&amp;quot;, type(n))

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;add: [13.  7.  9.  8.]
sub: [ 5. -3. -3.  2.]
mul: [36. 10. 18. 15.]
div: [2.25      0.4       0.5       1.6666666]
mod: [1. 2. 3. 2.]
floordiv: [2. 0. 0. 1.]
[[9. 3.]
 [2. 5.]]
concat tensors: [9. 2. 3. 5. 4. 5. 6. 3.]
stack tensors: [[9. 2. 3. 5.]
 [4. 5. 6. 3.]]
x: [9. 2. 3. 5.] &amp;lt;class 'mindspore.common.tensor.Tensor'&amp;gt;
n: [9. 2. 3. 5.] &amp;lt;class 'numpy.ndarray'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;几种特殊tensor&lt;/h3&gt;
&lt;h4&gt;稀疏张量&lt;/h4&gt;
&lt;p&gt;稀疏张量中绝大部分元素的值为零。&lt;/p&gt;
&lt;p&gt;在某些应用场景中（比如推荐系统、分子动力学、图神经网络等），数据的特征是稀疏的，若使用普通张量表征这些数据会引入大量不必要的计算、存储和通讯开销。这时就可以使用稀疏张量来表征这些数据。&lt;/p&gt;
&lt;p&gt;MindSpore支持常用的&lt;code&gt;CSR&lt;/code&gt;和&lt;code&gt;COO&lt;/code&gt;两种稀疏数据格式，如&lt;code&gt;CSRTensor&lt;/code&gt;、&lt;code&gt;COOTensor&lt;/code&gt;和&lt;code&gt;RowTensor&lt;/code&gt;等&lt;/p&gt;
&lt;p&gt;常用稀疏张量的表达形式是&lt;code&gt;&amp;lt;indices:Tensor, values:Tensor, shape:Tensor&amp;gt;&lt;/code&gt;。其中，&lt;code&gt;indices&lt;/code&gt;表示非零下标元素， &lt;code&gt;values&lt;/code&gt;表示非零元素的值，shape表示的是被压缩的稀疏张量的形状。&lt;/p&gt;
&lt;h5&gt;CSRTensor&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;CSR&lt;/code&gt;（Compressed Sparse Row，压缩稀疏行）稀疏张量格式有着高效的存储与计算的优势。其中，非零元素的值存储在&lt;code&gt;values&lt;/code&gt;中，非零元素的位置存储在&lt;code&gt;indptr&lt;/code&gt;（行）和&lt;code&gt;indices&lt;/code&gt;（列）中。各参数含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;indptr&lt;/code&gt;: 一维整数张量, 表示稀疏数据每一行的非零元素在&lt;code&gt;values&lt;/code&gt;中的起始位置和终止位置, 索引数据类型支持int16、int32、int64。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;indices&lt;/code&gt;: 一维整数张量，表示稀疏张量非零元素在列中的位置, 与&lt;code&gt;values&lt;/code&gt;长度相等，索引数据类型支持int16、int32、int64。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;values&lt;/code&gt;: 一维张量，表示&lt;code&gt;CSRTensor&lt;/code&gt;相对应的非零元素的值，与&lt;code&gt;indices&lt;/code&gt;长度相等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shape&lt;/code&gt;: 表示被压缩的稀疏张量的形状，数据类型为&lt;code&gt;Tuple&lt;/code&gt;，目前仅支持二维&lt;code&gt;CSRTensor&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; CSRTensor有以下限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CSR仅能表示二维张量&lt;/li&gt;
&lt;li&gt;行张量&lt;code&gt;indptr&lt;/code&gt;的&lt;code&gt;size&lt;/code&gt;为&lt;code&gt;csrtensor.shape[0]+1&lt;/code&gt;，其索引i表示csr张量第i行，值为列张量&lt;code&gt;indices&lt;/code&gt;索引，即指向该行第一个非0元素列位置&lt;/li&gt;
&lt;li&gt;列张量&lt;code&gt;indices&lt;/code&gt;，存储每个非0元素的列位置，长度与值张量&lt;code&gt;values&lt;/code&gt;相等，&lt;code&gt;indices[i]&lt;/code&gt; 表示第i个非0元素所在列位置&lt;/li&gt;
&lt;li&gt;值张量&lt;code&gt;values&lt;/code&gt; 存储csr所有非0值，按先行后列排序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 在Ascend平台，CSRTensor很多运算不可用&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;indptr = Tensor([0, 2, 4], dtype=mindspore.int32)
indices = Tensor([0, 2, 1, 3], dtype=mindspore.int32)
values = Tensor([1, 5, 2, 9], dtype=mindspore.float32)
shape = (2, 4)

# Make a CSRTensor
csr_tensor = CSRTensor(indptr, indices, values, shape)

print(csr_tensor.astype(mindspore.float64).dtype)
print(csr_tensor)
# 第一行元素indptr[0]首个非零元素在indices[indptr[0]]列出现，值为values[indptr[0]]
# 第二行元素indptr[1]首个非零元素在indices[indptr[1]]列出现，值为values[indptr[1]]
# values[indptr[0],indptr[1]]为第一行所有非零元素，列位置在indices中
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Float64
CSRTensor(shape=[2, 4], dtype=Float32, indptr=Tensor(shape=[3], dtype=Int32, value=[0 1 2]), indices=Tensor(shape=[4], dtype=Int32, value=[0 2 1 3]), values=Tensor(shape=[4], dtype=Float32, value=[ 1.00000000e+00  5.00000000e+00  2.00000000e+00  9.00000000e+00]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码表示如下所示的&lt;code&gt;CSRTensor&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;$$
\left[
\begin{matrix}
1 &amp;amp; 0 &amp;amp; 5 &amp;amp; 0 \
0 &amp;amp; 2 &amp;amp; 0 &amp;amp; 9
\end{matrix}
\right]
$$&lt;/p&gt;
&lt;h5&gt;COOTensor&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;COO&lt;/code&gt;（Coordinate Format）稀疏张量格式用来表示某一张量在给定索引上非零元素的集合，若非零元素的个数为&lt;code&gt;N&lt;/code&gt;，被压缩的张量的维数为&lt;code&gt;ndims&lt;/code&gt;。各参数含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;indices&lt;/code&gt;: 二维整数张量，每行代表非零元素下标。形状：&lt;code&gt;[N, ndims]&lt;/code&gt;， 索引数据类型支持int16、int32、int64。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;values&lt;/code&gt;: 一维张量，表示相对应的非零元素的值。形状：&lt;code&gt;[N]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shape&lt;/code&gt;: 表示被压缩的稀疏张量的形状，目前仅支持二维&lt;code&gt;COOTensor&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; values中每个非零元素values[i]在COOTensor中的坐标为indices[i]，因此可支持多维Tensor&lt;/p&gt;
&lt;p&gt;下面给出一些COOTensor的使用示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;indices = Tensor([[0, 1], [1, 2]], dtype=mindspore.int32)
values = Tensor([1, 2], dtype=mindspore.float32)
shape = (3, 4)

# Make a COOTensor
COOTensor(indices, values, shape)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;COOTensor(shape=[3, 4], dtype=Float32, indices=Tensor(shape=[2, 2], dtype=Int32, value=
[[0 1]
 [1 2]]), values=Tensor(shape=[2], dtype=Float32, value=[ 1.00000000e+00  2.00000000e+00]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码表示如下所示的&lt;code&gt;COOTensor&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;$$
\left[
\begin{matrix}
0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \
0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 \
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0
\end{matrix}
\right]
$$&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from datetime import datetime
import pytz
print(datetime.now(pytz.timezone('Asia/Shanghai')), '\nuser:YZSH-HSZY')
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2024-07-04 16:08:16.273507+08:00 
user:YZSH-HSZY
&lt;/code&gt;&lt;/pre&gt;
</content><category term="Mindspore"/></entry><entry><title>MindSpore Learen Notes -- QuikStart.</title><link href="https://yzsh-hszy.github.io/2024-07-01-mindspore-learen-notes-quikstart.html" rel="alternate"/><published>2024-07-01T12:00:00+08:00</published><updated>2024-07-01T12:00:00+08:00</updated><author><name>YZSH-HSZY</name></author><id>tag:yzsh-hszy.github.io,2024-07-01:/2024-07-01-mindspore-learen-notes-quikstart.html</id><summary type="html">&lt;h1&gt;mindspore介绍&lt;/h1&gt;
&lt;p&gt;昇思MindSpore是一个全场景深度学习框架，旨在实现易开发、高效执行、全场景统一部署三大目标。
昇思提供一系列配套设施能够为简化深度学习过程，并提 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;mindspore介绍&lt;/h1&gt;
&lt;p&gt;昇思MindSpore是一个全场景深度学习框架，旨在实现易开发、高效执行、全场景统一部署三大目标。
昇思提供一系列配套设施能够为简化深度学习过程，并提供一些工具用于辅助开发AI项目。&lt;/p&gt;
&lt;h2&gt;mindspore名词解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shuffle(清洗)
数据集随机shuffle可以消除数据排列造成的分布不均问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map(映射，一般用于变换)
map操作是数据预处理的关键操作，可以针对数据集指定列（column）添加数据变换（Transforms），将数据变换应用于该列数据的每个元素，并返回包含变换后元素的新数据集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;batch(批大小,统一批操作时数据保持相同形状)
将数据集打包为固定大小的batch是在有限硬件资源下使用梯度下降进行模型优化的折中方法，可以保证梯度下降的随机性和优化计算量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;设置batch后，在随后的数据集每一次迭代获取数据时，返回一个batch大小的批数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;自定义数据集
mindspore.dataset 模块提供了一些常用的公开数据集(公开数据集请使用download下载，dataset只能加载本地数据集)和标准格式数据集的加载API。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于MindSpore暂不支持直接加载的数据集，可以构造自定义数据加载类或自定义数据集生成函数的方式来生成数据集，然后通过GeneratorDataset接口实现自定义方式的数据集加载。&lt;/p&gt;
&lt;p&gt;GeneratorDataset支持通过可随机访问数据集对象、可迭代数据集对象和生成器(generator)构造自定义数据集，下面分别对其进行介绍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可随机访问数据集
可随机访问数据集是实现了__getitem__和__len__方法的数据集，表示可以通过索引/键直接访问对应位置的数据样本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可迭代数据集
可迭代的数据集是实现了__iter__和__next__方法的数据集，表示可以通过迭代的方式逐步获取数据样本。这种类型的数据集特别适用于随机访问成本太高或者不可行的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成器
生成器也属于可迭代的数据集类型，其直接依赖Python的生成器类型generator返回数据，直至生成器抛出StopIteration异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RGB图像格式
rgb图像是常见的彩色图像格式，但他在计算机内存中的存储顺序通常是按照BGR的顺序排列的。因为在Windows平台上，像素数据是按照BGR的顺序存储在内存中的。因此，当OpenCV之类的图像库读取一张RGB图像时，它会将像素数据按照BGR的顺序排列在内存中，而不是RGB的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HWC格式
HWC格式是指按照高度、宽度和通道数的顺序排列图像尺寸的格式。例如，一张形状为256×256×3的RGB图像，在HWC格式中表示为[256, 256, 3]。在一些图像处理库或者底层框架中，例如OpenCV和TensorFlow，通常使用HWC格式表示图像尺寸。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CHW格式
CHW格式是指按照通道数、高度和宽度的顺序排列图像尺寸的格式。在计算机视觉和深度学习中，通常使用CHW格式表示图像尺寸。如PyTorch等，因此转换CHW格式和HWC格式是有必要的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;实战&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import mindspore
from mindspore import nn
from mindspore.dataset import vision, transforms
from mindspore.dataset import MnistDataset
print('mindspore base moudle import')

# mindspore.dataset 模块提供api来加载和处理各种常用数据集，如MNIST、CIFAR-10, CIFAR-100, VOC, COCO, ImageNet, CelebA, CLUE等
# 它还支持数据集包括 MindRecord、TFRecord、Manifest等。用户还可以定义他们自己的数据集在这个模块。此外，该模块还提供了在加载时采样数据的api。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mindspore base moudle import
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# MNIST_Data数据集下载
# mnist数据集是由美国国家标准与技术研究所提供的手写数字图片数据集
from download import download

url = &amp;quot;https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/&amp;quot; \
      &amp;quot;notebook/datasets/MNIST_Data.zip&amp;quot;
path = download(url, &amp;quot;./&amp;quot;, kind=&amp;quot;zip&amp;quot;, replace=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Downloading data from https://mindspore-website.obs.cn-north-4.myhuaweicloud.com/notebook/datasets/MNIST_Data.zip (10.3 MB)

file_sizes: 100%|███████████████████████████| 10.8M/10.8M [00:00&amp;lt;00:00, 136MB/s]
Extracting zip file...
Successfully downloaded / unzipped to ./
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(MnistDataset.__doc__)
# mnist数据集包含以下内容
# mnist_dataset_dir
 # ├── t10k-images-idx3-ubyte (10000个测试图片)
 # ├── t10k-labels-idx1-ubyte (10000个测试标签)
 # ├── train-images-idx3-ubyte (60000个训练图片)
 # └── train-labels-idx1-ubyte (60000个训练标签)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    MNIST dataset.

    The generated dataset has two columns :py:obj:`[image, label]` .
    The tensor of column :py:obj:`image` is of the uint8 type.
    The tensor of column :py:obj:`label` is a scalar of the uint32 type.

    Args:
        dataset_dir (str): Path to the root directory that contains the dataset.
        usage (str, optional): Usage of this dataset, can be ``'train'`` , ``'test'`` or ``'all'`` .
            ``'train'`` will read from 60,000 train samples, ``'test'`` will read from 10,000 test samples,
            ``'all'`` will read from all 70,000 samples. Default: ``None`` , will read all samples.
        num_samples (int, optional): The number of images to be included in the dataset.
            Default: ``None`` , will read all images.
        num_parallel_workers (int, optional): Number of worker threads to read the data.
            Default: ``None`` , will use global default workers(8), it can be set
            by :func:`mindspore.dataset.config.set_num_parallel_workers` .
        shuffle (bool, optional): Whether or not to perform shuffle on the dataset.
            Default: ``None`` , expected order behavior shown in the table below.
        sampler (Sampler, optional): Object used to choose samples from the
            dataset. Default: ``None`` , expected order behavior shown in the table below.
        num_shards (int, optional): Number of shards that the dataset will be divided into. Default: ``None`` .
            When this argument is specified, `num_samples` reflects the maximum sample number of per shard.
        shard_id (int, optional): The shard ID within `num_shards` . Default: ``None`` . This
            argument can only be specified when `num_shards` is also specified.
        cache (DatasetCache, optional): Use tensor caching service to speed up dataset processing. More details:
            `Single-Node Data Cache &amp;lt;https://www.mindspore.cn/tutorials/experts/en/r2.2/dataset/cache.html&amp;gt;`_ .
            Default: ``None`` , which means no cache is used.

    Raises:
        RuntimeError: If `dataset_dir` does not contain data files.
        ValueError: If `num_parallel_workers` exceeds the max thread numbers.
        ValueError: If `usage` is not ``'train'``、``'test'`` or ``'all'``.
        RuntimeError: If `sampler` and `shuffle` are specified at the same time.
        RuntimeError: If `sampler` and `num_shards`/`shard_id` are specified at the same time.
        RuntimeError: If `num_shards` is specified but shard_id is None.
        RuntimeError: If `shard_id` is specified but `num_shards` is None.
        ValueError: If `shard_id` is not in range of [0, `num_shards` ).

    Tutorial Examples:
        - `Load &amp;amp; Process Data With Dataset Pipeline
          &amp;lt;https://www.mindspore.cn/docs/en/r2.2/api_python/samples/dataset/dataset_gallery.html&amp;gt;`_

    Note:
        - The parameters `num_samples` , `shuffle` , `num_shards` , `shard_id` can be used to control the sampler
          used in the dataset, and their effects when combined with parameter `sampler` are as follows.

    .. include:: mindspore.dataset.sampler.txt

    Examples:
        &amp;gt;&amp;gt;&amp;gt; import mindspore.dataset as ds
        &amp;gt;&amp;gt;&amp;gt; mnist_dataset_dir = &amp;quot;/path/to/mnist_dataset_directory&amp;quot;
        &amp;gt;&amp;gt;&amp;gt;
        &amp;gt;&amp;gt;&amp;gt; # Read 3 samples from MNIST dataset
        &amp;gt;&amp;gt;&amp;gt; dataset = ds.MnistDataset(dataset_dir=mnist_dataset_dir, num_samples=3)
        &amp;gt;&amp;gt;&amp;gt;
        &amp;gt;&amp;gt;&amp;gt; # Note: In mnist_dataset dataset, each dictionary has keys &amp;quot;image&amp;quot; and &amp;quot;label&amp;quot;

    About MNIST dataset:

    The MNIST database of handwritten digits has a training set of 60,000 examples,
    and a test set of 10,000 examples. It is a subset of a larger set available from
    NIST. The digits have been size-normalized and centered in a fixed-size image.

    Here is the original MNIST dataset structure.
    You can unzip the dataset files into this directory structure and read by MindSpore's API.

    .. code-block::

        .
        └── mnist_dataset_dir
             ├── t10k-images-idx3-ubyte
             ├── t10k-labels-idx1-ubyte
             ├── train-images-idx3-ubyte
             └── train-labels-idx1-ubyte

    Citation:

    .. code-block::

        @article{lecun2010mnist,
        title        = {MNIST handwritten digit database},
        author       = {LeCun, Yann and Cortes, Corinna and Burges, CJ},
        journal      = {ATT Labs [Online]},
        volume       = {2},
        year         = {2010},
        howpublished = {http://yann.lecun.com/exdb/mnist}
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 查看MNIST_Data数据集内容

import numpy as np
import matplotlib.pyplot as plt
# 加载数据集，包含图像和标签两部分
train_dataset = MnistDataset(&amp;quot;MNIST_Data/train&amp;quot;, shuffle=False)
print('dataset:', type(train_dataset))
print('dataset`s cloumns is: ', train_dataset.get_col_names())

def visualize(dataset):
    &amp;quot;&amp;quot;&amp;quot;
    查看数据集中部分内容，这里是图片
    Args:
        dataset (_type_): 数据集
    &amp;quot;&amp;quot;&amp;quot;
    figure = plt.figure(figsize=(4, 4))
    cols, rows = 3, 3

    plt.subplots_adjust(wspace=0.5, hspace=0.5)

    for idx, (image, label) in enumerate(dataset.create_tuple_iterator()):
        figure.add_subplot(rows, cols, idx + 1)
        plt.title(int(label))
        plt.axis(&amp;quot;off&amp;quot;)
        plt.imshow(image.asnumpy().squeeze(), cmap=&amp;quot;gray&amp;quot;)
        if idx == cols * rows - 1:
            break
    plt.show()
visualize(train_dataset)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;dataset: &amp;lt;class 'mindspore.dataset.engine.datasets_vision.MnistDataset'&amp;gt;
dataset`s cloumns is:  ['image', 'label']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="/static/mindspore/blog-doc_quikStarting_files/blog-doc_quikStarting_5_1.png" alt="png" /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;img, label = next(train_dataset.create_tuple_iterator())
print('the img chw is : ', img.shape) # mnist数据中每张图像是一个25*25的灰度图
print('the label is : ', label)

def datapipe(dataset: MnistDataset, batch_size: int):
    image_transforms = [
        vision.Rescale(1.0 / 255.0, 0), # 将图像进行缩放处理
        vision.Normalize(mean=(0.1307,), std=(0.3081,)), # 将图像进行归一化处理
        vision.HWC2CHW() 
    ]
    label_transform = transforms.TypeCast(mindspore.int32)
    
    dataset = dataset.map(image_transforms, input_columns='image')
    dataset = dataset.map(label_transform, input_columns='label')
    dataset = dataset.batch(batch_size)
    return dataset
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;the img chw is :  (28, 28, 1)
the label is :  5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# 数据处理
test_dataset = MnistDataset('MNIST_Data/test')

train_dataset = datapipe(train_dataset, 64)
test_dataset = datapipe(test_dataset, 64)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;mindspore.dataset.engine.datasets_vision.MnistDataset
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;网络构建&lt;/h3&gt;
&lt;p&gt;神经网络模型是由神经网络层和Tensor操作构成的，mindspore.nn 提供了常见神经网络层的实现，在MindSpore中，Cell类是构建所有网络的基类，也是网络的基本单元。一个神经网络模型表示为一个Cell，它由不同的子Cell构成。使用这样的嵌套结构，可以简单地使用面向对象编程的思维，对神经网络结构进行构建和管理。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义模型类
当我们定义神经网络时，可以继承 nn.Cell 类，在__init__方法中进行子Cell的实例化和状态管理，在construct(构造)方法中实现Tensor操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;construct意为神经网络（或计算图）构建，相关内容详见使用静态图加速。construct()方法不可直接调用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Net(nn.Cell):
    def __init__(self):
        super().__init__()
        self.flatten = nn.Flatten()
        self.dense_relu_sequential = nn.SequentialCell(
            nn.Dense(28*28, 512),
            nn.ReLU(),
            nn.Dense(512, 512),
            nn.ReLU(),
            nn.Dense(512, 10)
        )
        
    def construct(self, x):
        x = self.flatten(x)
        logits = self.dense_relu_sequential(x)
        return logits
model = Net()
# 查看神经网络结构
print(model)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Net&amp;lt;
  (flatten): Flatten&amp;lt;&amp;gt;
  (dense_relu_sequential): SequentialCell&amp;lt;
    (0): Dense&amp;lt;input_channels=784, output_channels=512, has_bias=True&amp;gt;
    (1): ReLU&amp;lt;&amp;gt;
    (2): Dense&amp;lt;input_channels=512, output_channels=512, has_bias=True&amp;gt;
    (3): ReLU&amp;lt;&amp;gt;
    (4): Dense&amp;lt;input_channels=512, output_channels=10, has_bias=True&amp;gt;
    &amp;gt;
  &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from datetime import datetime
import pytz
print(datetime.now(pytz.timezone('Asia/Shanghai')))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2024-06-28 21:12:18.029531+08:00
&lt;/code&gt;&lt;/pre&gt;
</content><category term="MindSpore"/></entry></feed>